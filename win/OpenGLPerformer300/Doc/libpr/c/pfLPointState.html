<HTML>
<HEAD>
<TITLE>pfLPointState</TITLE>
</HEAD>
<BODY>
<H1>pfLPointState</H1>
<HR>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->
pfLPointState(3pf)                             pfLPointState(3pf)




</PRE>
<H2>NAME</H2><PRE>
       <B>pfNewLPState,</B>     <B>pfGetLPStateClassType,</B>    <B>pfLPStateMode,</B>
       <B>pfGetLPStateMode,</B>  <B>pfLPStateVal,</B>  <B>pfGetLPStateVal,</B>   <B>pfLP-</B>
       <B>StateShape,</B>     <B>pfGetLPStateShape,</B>     <B>pfLPStateBackColor,</B>
       <B>pfGetLPStateBackColor,</B> <B>pfApplyLPState,</B> <B>pfMakeLPStateRange-</B>
       <B>Tex,</B> <B>pfMakeLPStateShapeTex,</B> <B>pfRasterFunc,</B> <B>pfGetRasterFunc,</B>
       <B>pfCalligFunc,</B> <B>pfGetCalligFunc,</B> <B>pfGetCurLPState</B> -  Set  and
       get   pfLPointState  size,  transparency,  directionality,
       shape, and fog attributes.


</PRE>
<H2>FUNCTION SPECIFICATION</H2><PRE>
       #include &lt;Performer/pr.h&gt;

       pfLPointState *   <B>pfNewLPState</B>(void *arena);

       pfType *          <B>pfGetLPStateClassType</B>(void);

       void              <B>pfLPStateMode</B>(pfLPointState *lpstate,
                           int mode, int val);

       int               <B>pfGetLPStateMode</B>(const pfLPointState *lpstate,
                           int mode);

       void              <B>pfLPStateVal</B>(pfLPointState *lpstate,
                           int attr, float val);

       float             <B>pfGetLPStateVal</B>(const pfLPointState *lpstate,
                           int attr);

       void              <B>pfLPStateShape</B>(pfLPointState *lpstate,
                           float horiz, float vert, float roll,
                           float falloff, float ambient);

       void              <B>pfGetLPStateShape</B>(const pfLPointState *lpstate,
                           float *horiz,           float *vert,
                           float *roll,         float *falloff,
                           float *ambient);

       void              <B>pfLPStateBackColor</B>(pfLPointState *lpstate,
                           float r, float g, float b, float a);

       void              <B>pfGetLPStateBackColor</B>(pfLPointState *lpstate,
                           float *r,    float *g,     float *b,
                           float *a);

       void              <B>pfApplyLPState</B>(pfLPointState *lpstate);

       void              <B>pfMakeLPStateRangeTex</B>(pfLPointState *lpstate,
                           pfTexture *tex,            int size,
                           pfFog* fog);

       void              <B>pfMakeLPStateShapeTex</B>(pfLPointState *lpstate,
                           pfTexture *tex, int size);

       void              <B>pfRasterFunc</B>(pfLPointState *lpstate,
       void              <B>pfCalligFunc</B>(pfLPointState *lpstate,
                           pfCalligFuncType calligCallback,
                           void *calligData);

       void              <B>pfGetCalligFunc</B>(pfLPointState *lpstate,
                           pfCalligFuncType *calligCallback,
                           void **calligData);

       pfLPointState*    <B>pfGetCurLPState</B>(void);


</PRE>
<H2>PARENT CLASS FUNCTIONS</H2><PRE>
       The OpenGL Performer class <B>pfLPointState</B> is  derived  from
       the  parent  class <B>pfObject</B>, so each of these member func-
       tions of class <B>pfObject</B>  are  also  directly  usable  with
       objects  of  class  <B>pfLPointState</B>.   Casting  an object of
       class <B>pfLPointState</B> to an  object  of  class  <B>pfObject</B>  is
       taken  care of automatically.  This is also true for casts
       to objects of ancestor classes of class <B>pfObject</B>.

       void          <B>pfUserDataSlot</B>(pfObject *obj,      int slot,
                       void *data);
       void          <B>pfUserData</B>(pfObject *obj, void *data);
       void*         <B>pfGetUserDataSlot</B>(pfObject *obj, int slot);
       void*         <B>pfGetUserData</B>(pfObject *obj);
       int           <B>pfGetNumUserData</B>(pfObject *obj);
       int           <B>pfGetNamedUserDataSlot</B>(const char *name);
       const char*   <B>pfGetUserDataSlotName</B>(int slot);
       int           <B>pfGetNumNamedUserDataSlots</B>(void);
       int           <B>pfGetGLHandle</B>(pfObject *obj);
       int           <B>pfDeleteGLHandle</B>(pfObject *obj);


       Since the class <B>pfObject</B> is itself derived from the parent
       class <B>pfMemory</B>, objects of class <B>pfLPointState</B> can also be
       used  with  these  functions designed for objects of class
       <B>pfMemory</B>.

       pfType *       <B>pfGetType</B>(const void *ptr);
       int            <B>pfIsOfType</B>(const void *ptr, pfType *type);
       int            <B>pfIsExactType</B>(const void *ptr,
                        pfType *type);
       const char *   <B>pfGetTypeName</B>(const void *ptr);
       int            <B>pfRef</B>(void *ptr);
       int            <B>pfUnref</B>(void *ptr);
       int            <B>pfUnrefDelete</B>(void *ptr);
       int            <B>pfUnrefGetRef</B>(void *ptr);
       int            <B>pfGetRef</B>(const void *ptr);
       int            <B>pfCopy</B>(void *dst, void *src);
       int            <B>pfDelete</B>(void *ptr);
       int            <B>pfIsFluxed</B>(void *ptr);
       int            <B>pfCompare</B>(const void *ptr1,
                        const void *ptr2);
       void           <B>pfPrint</B>(const void *ptr,        uint which,
                        uint verbose, FILE *file);
       void *         <B>pfGetArena</B>(void *ptr);


</PRE>
<H2>PARAMETERS</H2><PRE>
       <I>lpstate</I>  identifies a pfLPointState.

       (PAPI),  and  street  lights when viewed from a great dis-
       tance.

       Light points should not be confused  with  light  sources,
       such as a pfLight. A light point is visible as one or more
       self-illuminated small points that do not illuminate  sur-
       rounding objects. By comparison, a pfLight does illuminate
       scene contents but is itself not a visible object.

       When a pfLPointState is  applied  with  <B>pfApplyLPState</B>  or
       through   its   parent   pfGeoState  (See  <B>pfDrawGSet</B>  and
       <B>pfApplyGState</B>), any pfGeoSet of type <B>PFGS_POINTS</B>  will  be
       rendered with the following special light point character-
       istics (if enabled):

              1. Perspective size. Light points can be assigned a
                 real  world  size and exhibit perspective behav-
                 ior, e.g., points closer to the eye will be ren-
                 dered larger than those points farther away.

              2. Perspective fading. Once a light point reaches a
                 minimum size, it may be made more transparent in
                 order to enhance the perspective illusion.  Fad-
                 ing is often more realistic than simply  shrink-
                 ing the point size to 0.

              3. Fog  punch-through. Since light points are emis-
                 sive objects, they must shine through  fog  more
                 than non-emissive objects.

              4. Directionality.  Light  points can be assigned a
                 direction as well  as  vertical  and  horizontal
                 envelopes  (or  lobes) about this direction vec-
                 tor. Directional light point intensity  is  then
                 view  position-dependent.  Light point direction
                 is defined by the  normals  (<B>PFGS_NORMAL3</B>)  sup-
                 plied by <B>PFGS_POINTS</B> pfGeoSets.

              5. Intensity.   Normally,  light  point  color  and
                 transparency  are  defined  by  the  colors   (-
                 <B>PFGS_COLOR4</B>)  supplied by <B>PFGS_POINTS</B> pfGeoSets.
                 pfLPointStates provide the additional capability
                 of  modifying  the  intensity of all points in a
                 light point pfGeoSet by scaling the alpha of all
                 point colors.

       At  a  minimum, light point usage requires a configuration
       based  on  three  linked  libpr  objects:  a  pfGeoSet,  a
       pfGeoState  attached to that pfGeoSet, and a pfLPointState
       attached to the pfGeoState. Here are the details:

              1. A pfGeoSet of type  <B>PFGS_POINTS</B>.  This  pfGeoSet
                 must  have  a  <B>PFGS_COLOR4</B>  attribute binding of
                 <B>PFGS_PER_VERTEX</B> in some  situations  and  should
                 have  supplied  normals  (<B>PFGS_NORMAL3</B>)  if  the
                 light points are directional.

              2. A pfGeoState which is usually  attached  to  the
              pfGeoSet and
                 pfGeoState listed in step two.

       The  following  example illustrates how to build a compre-
       hensive light point structure that uses texture mapping to
       accelerate directionality computations:


       /*
        * Create pfLPointState and pfGeoState.
        */
       pfGeoState     *gst = pfNewGState(arena);
       pfLPointState  *lps = pfNewLPState(arena);
       pfGStateMode(gst, PFSTATE_ENLPOINTSTATE, 1);
       pfGStateAttr(gst, PFSTATE_LPOINTSTATE, lps);

       /*
        * Light point projected diameter is computed on CPU. Real world
        * size is 0.07 database units and projected size is clamped be
        * between 0.25 and 4 pixels.
        */
       pfLPStateMode(lps, PFLPS_SIZE_MODE, PFLPS_SIZE_MODE_ON);
       pfLPStateVal(lps, PFLPS_SIZE_MIN_PIXEL, 0.25f);
       pfLPStateVal(lps, PFLPS_SIZE_ACTUAL, 0.07f);
       pfLPStateVal(lps, PFLPS_SIZE_MAX_PIXEL, 4.0f);

       /*
        * Light points become transparent when their projected diameter is
        * &lt; 2 pixels. The transparency falloff rate is linear with
        * projected size with a scale factor of 0.6. The transparency
        * multiplier, NOT the light point transparency, is clamped to 0.1.
        */
       pfLPStateVal(lps, PFLPS_TRANSP_PIXEL_SIZE, 2.0f);
       pfLPStateVal(lps, PFLPS_TRANSP_EXPONENT, 1.0f);
       pfLPStateVal(lps, PFLPS_TRANSP_SCALE, 0.6f);
       pfLPStateVal(lps, PFLPS_TRANSP_CLAMP, 0.1f);

       /*
        * Light points will be fogged as if they were 4 times
        * nearer to the eye than actual to achieve punch-through.
        */
       pfLPStateVal(lps, PFLPS_FOG_SCALE, 0.25f);

       /* Range to light points computed on CPU is true range */
       pfLPStateMode(lps, PFLPS_RANGE_MODE, PFLPS_RANGE_MODE_TRUE);

       /*
        * Light points are bidirectional but have different (magenta)
        * back color. Front color is provided by pfGeoSet colors.
        */
       pfLPStateMode(lps, PFLPS_SHAPE_MODE, PFLPS_SHAPE_MODE_BI_COLOR);
       pfLPStateBackColor(lps, 1.0f, 0.0f, 1.0f, 1.0f);

       /*
        * 60 degrees horizontal and 30 degrees vertical envelope.
        * Envelope is rotated -25 degrees about the light point
        * direction. Falloff rate is linear and ambient intensity is 0.1.
        */
       pfLPStateShape(lps, 60.0f, 30.0f, -25.0f, 1.0f, 0.1f);

       pfLPStateMode(lps, PFLPS_TRANSP_MODE, PFLPS_TRANSP_MODE_ALPHA);
       pfLPStateMode(lps, PFLPS_FOG_MODE, PFLPS_FOG_MODE_ALPHA);

       /*
        * Make directionality environment map of size 64 x 64 and attach
        * it to the light point pfGeoState. We assume that a pfTexEnv of
        * type PFTE_MODULATE has been globally applied with pfApplyTEnv.
        */
       tex = pfNewTex(arena);
       pfMakeLPStateShapeTex(lps, tex, 64);
       pfGStateAttr(gst, PFSTATE_TEXTURE, tex);
       pfGStateMode(gst, PFSTATE_ENTEXTURE, 1);

       /*
        * Make SPHERE_MAP pfTexGen and attach to light point pfGeoState.
        * pfGeoSet normals define the per-light light point direction.
        */
       tgen = pfNewTGen(arena);
       pfTGenMode(tgen, PF_S, PFTG_SPHERE_MAP);
       pfTGenMode(tgen, PF_T, PFTG_SPHERE_MAP);
       pfGStateAttr(gst, PFSTATE_TEXGEN, tgen);
       pfGStateMode(gst, PFSTATE_ENTEXGEN, 1);

       /*
        * Configure light point transparency. Use PFTR_BLEND_ALPHA for high
        * quality transparency. Set pfAlphaFunc so that light points are not
        * drawn unless their alphas exceed 1 when using 8-bit color resolution.
        */
       pfGStateMode(gst, PFSTATE_TRANSPARENCY, PFTR_BLEND_ALPHA);
       pfGStateVal(gst, PFSTATE_ALPHAREF, 1.0/255.0);
       pfGStateMode(gst, PFSTATE_ALPHAFUNC, PFAF_GREATER);

       /*
        * Disable pfFog effects since light points are fogged by
        * the pfLPointState.
        */
       pfGStateMode(gst, PFSTATE_ENFOG, 0);
       /*
        * Disable lighting effects since light points are completely
        * emissive.
        */
       pfGStateMode(gst, PFSTATE_ENLIGHTING, 0);

       /*
        * Attach the pfGeoState to a pfGeoSet of type PFGS_POINTS and
        * you've got light points!
        */
       pfGSetPrimType(gset, PFGS_POINTS);
       pfGSetGState(gset, gst);


       <B>pfLPointState</B> <B>Modes</B>

       Each of the five light point characteristics listed ear-
       lier may be achieved through the Graphics Library in dif-
       ferent ways depending on the available graphics hardware.
       <B>pfLPStateMode</B>/<B>pfLPStateVal</B> provide control over feature
       implementation. Modes and their corresponding values
       accepted by <B>pfLPStateMode</B> are:
                 point size.

              <B>PFLPS_TRANSP_MODE</B>  /* Perspective fading */
                 <B>PFLPS_TRANSP_MODE_ON</B> - Enable default (CPU-
                 based) light point fading.

                 <B>PFLPS_TRANSP_MODE_OFF</B> - Disable light point fad-
                 ing.

                 <B>PFLPS_TRANSP_MODE_ALPHA</B> - Enable light point
                 fading. Compute fade value on CPU and modify
                 light point alpha. This mode requires that
                 pfGeoSets have a <B>PFGS_COLOR4</B> binding of
                 <B>PFGS_PER_VERTEX</B> and that there be a unique color
                 for each point.

                 <B>PFLPS_TRANSP_MODE_TEX</B> - Enable light point fad-
                 ing. Use texture mapping to simulate fading.

              <B>PFLPS_FOG_MODE</B>  /* Fog punch-through */
                 <B>PFLPS_FOG_MODE_ON</B> - Enable default (CPU-based)
                 fog punch-through.

                 <B>PFLPS_FOG_MODE_OFF</B> - Disable fog punch-through.

                 <B>PFLPS_FOG_MODE_ALPHA</B> - Enable fog punch-through.
                 Compute fog value on CPU and modify light point
                 alpha. This mode requires that pfGeoSets have a
                 <B>PFGS_COLOR4</B> binding of <B>PFGS_PER_VERTEX</B> and that
                 there be a unique color for each point.

                 <B>PFLPS_FOG_MODE_TEX</B> - Enable fog punch-through.
                 Use texture mapping to simulate fog.

                 (Normal fogging should be disabled (-
                 <B>pfDisable(PFEN_FOG)</B> or <B>pfGStateMode(g,</B> <B>PFS-</B>
                 <B>TATE_ENFOG,</B> <B>0)</B>) when <B>PFLPS_FOG_MODE</B> is not
                 <B>PFLPS_FOG_MODE_OFF</B> since the pfLPointState will
                 fog the points)


              <B>PFLPS_DIR_MODE</B>  /* Directionality enable */
                 <B>PFLPS_DIR_MODE_ON</B> - Enable default (CPU-based)
                 directional light points.

                 <B>PFLPS_DIR_MODE_OFF</B> - Disable directional light
                 points.

                 <B>PFLPS_DIR_MODE_ALPHA</B> - Enable directional light
                 points. Compute directionality on CPU and modify
                 light point alpha. This mode requires that
                 pfGeoSets have a <B>PFGS_COLOR4</B> binding of
                 <B>PFGS_PER_VERTEX</B> and that there be a unique color
                 for each point.

                 <B>PFLPS_DIR_MODE_TEX</B> - Enable directional light
                 points. Use texture mapping to simulate direc-
                 tionality.

                 are bidirectional with identical front and back
                 colors. Light distribution is two elliptical
                 cones, specified by <B>pfLPStateShape</B>, centered
                 about the positive and negative light direction
                 vectors.

                 <B>PFLPS_SHAPE_MODE_BI_COLOR</B> - Directional light
                 points are bidirectional with back color speci-
                 fied by <B>pfLPStateBackColor</B>. Light distribution
                 is two elliptical cones, specified by
                 <B>pfLPStateShape</B>, centered about the positive and
                 negative light direction vectors.

              <B>PFLPS_RANGE_MODE</B>
                 <B>PFLPS_RANGE_MODE_DEPTH</B> - Range to light point is
                 approximated by depth from eye. This may be
                 faster, but less accurate than
                 <B>PFLPS_RANGE_MODE_TRUE</B>.

                 <B>PFLPS_RANGE_MODE_TRUE</B> - Range to light point is
                 true, slanted range to eye. This may be slower,
                 but more accurate than <B>PFLPS_RANGE_MODE_DEPTH</B>.

       <B>pfLPointState</B> <B>Values</B>

       <B>pfLPStateVal</B> sets the attribute of <I>lpstate</I> identified by
       <I>which</I> to <I>val</I>. <B>pfGetLPStateVal</B> returns the attribute of
       <I>lpstate</I> identified by <I>which</I>.

       Values associated with <B>PFLPS_SIZE_MODE</B> and which have
       effect only when <B>PFLPS_SIZE_MODE</B> is <B>PFLPS_SIZE_MODE_ON</B> are
       the following:

              <B>PFLPS_SIZE_MIN_PIXEL</B>
                     <I>val</I> specifies the minimum diameter, in pix-
                     els, of light points. Default value is 0.25.
                     Note that actual minimum point size is
                     clamped to the minimum supported by the
                     graphics hardware.

              <B>PFLPS_SIZE_MAX_PIXEL</B>
                     <I>val</I> specifies the maximum diameter, in pix-
                     els, of light points. Default value is 4.0.
                     Note that actual maximum point size is
                     clamped to the maximum supported by the
                     graphics hardware.

              <B>PFLPS_SIZE_ACTUAL</B>
                     <I>val</I> specifies light point diameter in eye
                     coordinates. Scales do not affect the actual
                     light point size.  Default value is 0.25.

       In pseudo-code, the size of a light point is determined as
       follows:

       /* NearPixelDistance is described below */
       computedSize = <B>PFLPS_SIZE_ACTUAL</B> * NearPixelDistance / rangeToEye;

       if (<B>PFLPS_SIZE_MODE</B> == <B>PFLPS</B> <B>_SIZE_MODE_ON</B>)

           lightPointSize = computedSize;
       }


       Values associated with <B>PFLPS_TRANSP_MODE</B> and which have
       effect only when <B>PFLPS_TRANSP_MODE</B> is not
       <B>PFLPS_TRANSP_MODE_OFF</B>.

              <B>PFLPS_TRANSP_PIXEL_SIZE</B>
                     <I>val</I> specifies the threshold diameter, in
                     pixels, at which light point alphas are
                     decreased so that they become more transpar-
                     ent once computed light point size is less
                     than <I>val</I>.  Default value is 0.25.

              <B>PFLPS_TRANSP_EXPONENT</B>
                     <I>val</I> specifies an exponential falloff for
                     light point fading and should be &gt;= 0.0.
                     Values &gt; 0 and &lt; 1 make the falloff curve
                     flatter while values &gt; 1 make it sharper.
                     Default value is 1.0 for a linear falloff
                     based on projected pixel size.

              <B>PFLPS_TRANSP_SCALE</B>
                     <I>val</I> specifies a scale factor for the light
                     point fade multiplier. Values &gt; 0 and &lt; 1
                     decrease the falloff rate while values &gt; 1
                     increase it.  Default value is 1.0.

              <B>PFLPS_TRANSP_CLAMP</B> - <I>val</I> specifies the minimum fade
              multiplier.

       In pseudo-code, the transparency of a light point is
       determined as follows:

       if (<B>PFLPS_TRANSP_MODE</B> == <B>PFLPS_TRANSP_MODE_ALPHA</B> &amp;&amp;
           <B>PFLPS_TRANSP_PIXEL_SIZE</B> &gt; computedSize)
       {
           float       a;

           a = 1.0f - <B>PFLPS_TRANSP_SCALE</B> *
            powf(<B>PFLPS_TRANSP_PIXEL_SIZE</B> - computedSize,
                 <B>PFLPS_TRANSP_EXPONENT</B>);

           /* Clamp alpha multiplier, not alpha */
           if (a &lt; <B>PFLPS_TRANSP_CLAMP</B>)
            a = <B>PFLPS_TRANSP_CLAMP</B>;

           lightPointAlpha *= a;
       }



       <B>PFLPS_FOG_SCALE</B>
              <I>val</I> specifies a scale factor that multiplies the
              range from eye to light point before fogging. Val-
              ues &gt; 0.0 and &lt; 1.0 cause light points to punch
              through fog more than non-emissive surfaces.


       <B>PFLPS_INTENSITY</B>
              <I>val</I> multiplies all light point alphas.  Default
              value is 1.0.

       <B>PFLPS_SIZE_DIFF_THRESH</B>
              <I>val</I> specifies the threshold, in pixels, at which a
              new point size should be specified to the Graphics
              Library.  It is strictly a tuning parameter which
              trades off speed for image quality. Default value
              is 0.1. Higher values improve performance but may
              degrade light point image quality.

       <B>PFLPS_TRANSP_MODE</B>, <B>PFLPS_FOG_MODE</B>, and <B>PFLPS_DIR_MODE</B>
       modes each have possible values of <B>ALPHA</B> and <B>TEX</B> which
       dictate the mechanism used to simulate the effect. The
       <B>ALPHA</B> mechanism is the default and uses the CPU to compute
       the effect which is then realized by modifying the alpha
       of light point colors.  pfGeoSets of type <B>PFGS_POINTS</B>
       which use an <B>ALPHA</B> mechanism should have a <B>PFGS_COLOR4</B>
       binding of <B>PFGS_PER_VERTEX</B> even if all point colors are
       the same, since the light point alphas will be different
       based on <B>ALPHA</B> computation by the pfLPointState.

       While <B>ALPHA</B> mechanisms are graphics hardware-independent,
       they may be slower than <B>TEX</B> mechanisms on machines which
       provide hardware texture mapping. By supplying an appro-
       priate pfTexture, pfTexGen, and pfTexEnv (usually attached
       to the pfGeoState to which the pfLPointState is attached),
       you can use the texture mapping hardware to efficiently
       simulate directionality or fog punch-through and perspec-
       tive fading. At this time it is not possible to support
       all <B>TEX</B> mechanisms at once:

              1.     Only <B>PFLPS_DIR_MODE_TEX</B> or,

              2.     <B>PFLPS_TRANSP_MODE_TEX</B> and/or
                     <B>PFLPS_FOG_MODE_TEX</B>
       It is recommended that directional light points use
       <B>PFLPS_DIR_MODE_TEX</B> since directionality is the most expen-
       sive effect to compute on the CPU.

       Two convenience routines, <B>pfMakeLPStateRangeTex</B> and
       <B>pfMakeLPStateShapeTex</B> are provided to compute a texture
       image which accurately mimics certain characteristics of
       <I>lpstate</I>.

       <B>pfMakeLPStateRangeTex</B> should be used in conjunction with
       <B>PFLPS_TRANSP_MODE_TEX</B> and/or <B>PFLPS_FOG_MODE_TEX</B> and will
       set a computed image on the supplied pfTexture, <I>tex</I>. The
       image will be a 2D array of <I>size</I> by <I>size</I> if both
       <B>PFLPS_TRANSP_MODE_TEX</B> and <B>PFLPS_FOG_MODE_TEX</B> are set on
       <I>lpstate</I> or the image will be a 1D array of length <I>size</I> if
       only 1 of <B>PFLPS_TRANSP_MODE_TEX</B> and <B>PFLPS_FOG_MODE_TEX</B> is
       set.

       When using <B>PFLPS_TRANSP_MODE_TEX</B> and/or
       <B>PFLPS_FOG_MODE_TEX</B>, you must supply a pfTexGen structure
       pfTGenPlane(tgen, PF_T, 0.0f, 0.0f, 1.0f, 0.0f);
       pfTGenMode(tgen, PF_S, PFTG_EYE_PLANE);
       pfTGenMode(tgen, PF_T, PFTG_EYE_PLANE);

       <B>pfMakeLPStateRangeTex</B> takes into account only the follow-
       ing values of <I>lpstate</I> when building the texture image and
       should be called again whenever they change:

              <B>PFLPS_TRANSP_PIXEL_SIZE</B>
              <B>PFLPS_TRANSP_EXPONENT</B>
              <B>PFLPS_TRANSP_SCALE</B>
              <B>PFLPS_TRANSP_CLAMP</B>

       <B>pfMakeLPStateShapeTex</B> computes an environment map which
       approximates the directional characteristics of <I>lpstate</I>.
       The computed image is assigned to <I>tex</I> and its dimensions
       are <I>size</I> by <I>size</I>. When using <B>PFLPS_DIR_MODE_TEX</B>, you must
       supply a pfTexGen structure which uses <B>PFTG_SPHERE_MAP</B> to
       compute both S and T. For example:

       tgen = pfNewTGen(arena);
       pfTGenMode(tgen, PF_S, PFTG_SPHERE_MAP);
       pfTGenMode(tgen, PF_T, PFTG_SPHERE_MAP);


       <B>pfMakeLPStateShapeTex</B> takes into account only the
       <B>PFLPS_SHAPE_MODE</B> modes and those values specified by
       <B>pfLPStateShape</B>. Consequently, <B>pfMakeLPStateShapeTex</B> should
       be called whenever these modes/values change.

       <I>fog</I> should represent the desired fog ramp, e.g.
       <B>PFFOG_LINEAR</B>, <B>PFFOG_SPLINE</B>, if <B>PFLPS_FOG_MODE_TEX</B> is set
       or NULL if not set. The fog ranges are ignored and <I>fog</I> is
       not modified.

       Each of the four main light point features (size, trans-
       parency, fog, and directionality) are view-dependent
       effects.  Consequently, knowledge about the viewing and
       modeling transformations is required in certain situa-
       tions:

              1. When not using <B>libpf</B>. Otherwise, <B>libpf</B> automati-
                 cally informs <B>libpr</B> of the viewing and modeling
                 transformations.

              2. When using an <B>ALPHA</B> mechanism, e.g.,
                 <B>PFLPS_DIR_MODE_ALPHA</B>.

              3. When <B>PFLPS_SIZE_MODE</B> is <B>PFLPS_SIZE_MODE_ON</B>.

       Use <B>pfViewMat</B> and <B>pfModelMat</B> to specify the viewing and
       modeling matrices respectively. For best performance,
       these routines should be called only when the correspond-
       ing matrix changes.  Additionally you may call
       <B>pfInvModelMat</B> to specify the inverse of the modeling
       matrix if you've already computed it for some other rea-
       son. When using <B>PFLPS_SIZE_MODE_ON</B>, use <B>pfNearPixDist</B> to
       specify the distance, in pixels, from the eye to the near
       clip plane.  pfLPointState needs this parameter to map
       the pfLPointState is allocated or <B>NULL</B> for allocation off
       the process heap.  pfLPointStates can be deleted with
       <B>pfDelete</B>.

       <B>pfGetLPStateClassType</B> returns the <B>pfType</B>* for the class
       <B>pfLPointState</B>.  The <B>pfType</B>* returned by
       <B>pfGetLPStateClassType</B> is the same as the <B>pfType</B>* returned
       by invoking <B>pfGetType</B> on any instance of class
       <B>pfLPointState</B>.  When decisions are made based on the type
       of an object, it is usually better to use <B>pfIsOfType</B> to
       test if an object is of a type derived from a Performer
       type rather than to test for strict equality of the
       <B>pfType</B>*'s.


       <B>pfLPointShape</B> specifies the light distribution character-
       istics of directional light points. Light point directions
       are specified by pfGeoSet normals after they have been
       transformed by the current modeling matrix. Note that a
       <B>PFGS_NORMAL3</B> binding of <B>PFGS_OVERALL</B> is permitted as well
       as a binding of <B>PFGS_PER_VERTEX</B>.  Directional light points
       require that <B>PFLPS_DIR_MODE</B> be <B>PFLPS_DIR_MODE_ON</B>,
       <B>PFLPS_DIR_MODE_ALPHA</B>, or <B>PFLPS_DIR_MODE_TEX</B>.

       <I>horiz</I> and <I>vert</I> are total-angles angles (not half-angles)
       in degrees which specify the horizontal and vertical
       envelopes about the direction vector. As such, the maximum
       value for these angles is 180 degrees, for a 180 degree
       lobe shape. An envelope is a symmetric angular spread in a
       specific plane about the light direction vector.  The
       default direction is along the positive Y axis so the hor-
       izontal envelope is in the X plane and the vertical in the
       Z plane. The envelopes are twisted about the +Y axis by
       <I>roll</I> degrees, then rotated by the rotation which takes the
       +Y axis onto the light point direction vector. Default
       values are:

              <I>horiz</I> = 90 degrees
              <I>vert</I> = 90 degrees
              <I>roll</I> = 0 degrees
              <I>falloff</I> = 1
              <I>ambient</I> = 0

       When the vector from the eyepoint to the light position is
       outside its envelope, the light point's intensity is <I>ambi-</I>
       <I>ent</I>.  If within, the intensity of the light point is com-
       puted based on the location of the eye within the ellipti-
       cal cone.  Intensity ranges from 1.0 when the eye lies on
       the light direction vector to <I>ambient</I> on the edge of the
       cone.  <I>falloff</I> is an exponent which modifies the inten-
       sity.  A value of 0 indicates that there is no falloff and
       values &gt; 0 increase the falloff rate.  The default <I>falloff</I>
       is 1.  As intensity decreases, the light point's trans-
       parency increases.

       <B>pfGetLPointShape</B> copies <I>lpstate</I>'s shape parameters into
       <I>horiz</I>, <I>vert</I>, <I>roll</I>, <I>falloff</I>, and <I>ambient</I>.

       <B>pfLPStateBackColor</B> specifies the back color of <I>lpstate</I>.
       which may be captured by an open pfDispList. A pfL-
       PointState may also be attached to a pfGeoState.
       <B>pfGetCurLPState</B> returns the current pfLPointState or NULL
       if there is none.


   <B>LIGHT</B> <B>POINTS</B> <B>PREPROCESSING</B>
       Light point processing can be heavy. One way is to reduce
       the load by using textures, but reducing the quality and
       precision of the light points. This may be acceptable in
       many case, but is not tolerable for high quality light
       points.

       An other way is to have a separate task to do the process-
       ing in parallel with the drawing of the scene, and then to
       draw the light points that have already been preprocessed.
       (see <B>pfPreprocessDList</B>)

       In that case, do not use textures simplification. This
       prevent preprocessing and also annul the following pfL-
       PointState callbacks. If you do not have a process dedi-
       cated to preprocess light points, and do not use texture
       simplification in a pfLPointState, you may use the follow-
       ing callbacks being conscious of the time taken out of the
       draw by the callback.

       <B>pfRasterFunc</B> sets the <I>rasterCallback</I> function and the user
       data (<I>data</I>) to the <I>lpstate</I>.

       <B>pfGetRasterFunc</B> gives back the current function and data.

       <B>pfCalligFunc</B> and <B>pfGetCalligFunc</B> do the same for the Cal-
       ligraphic Light Points callback as explained in the
       <B>pfCalligraphic</B> man pages.

       The object of those callbacks is to give access directly
       to the computation of each light in the pfGoeSet. The
       callback will be call when processing the pfLPointState
       only if the <B>PFLPS_CALLBACK_MODE</B> is not set to
       <B>PFLPS_CALLBACK_MODE_OFF</B>.

       Two modes are available:

       <B>PFLPS_CALLBACK_MODE_PRE</B> makes the callback to be invoked
       before IRIX Performer standard light points behaviour. Use
       this to implement your own attenuation algorithm.

       <B>PFLPS_CALLBACK_MODE_POST</B> makes the callback to be invoked
       after IRIX Performer do the standard computation. Use this
       to implement some nice animations, or final touch attenua-
       tion computation.


       When the callback returns, no further computation is done
       before the light points are drawn.

       The callback function receive many arguments (as defined
       in pr.h):


       <I>lpstate</I> is the pointer to the pfLPointState beeing pro-
       cessed.

       <I>geoset</I> is the pointer to the pfGeoSet beeing processed.

       <I>userData</I> is the pointer provided when declaring the call-
       back.

       <I>sizes</I>, <I>alphas</I> are the result of the light points computa-
       tion. They are allready allocated, even if it is a PRE
       callback.

       The <I>sizes</I> contains the size of each point in pixel unit,
       and <I>alpha</I> the transparency. The size is always a positive
       value, but an alpha value can be negative. A negative
       value tells to draw this point with the backColor, with an
       alpha value of -<I>alpha</I>.

       Here is an skeleton of a post callback:


       void myCallback(pfRasterData *rasterData)
       {
       pfVec3* vertices;
       unsigned short *vindex;
       pfVec3* norms;
       unsigned short *nindex;
       int nbind;
       pfVec4* colors;
       unsigned short *cindex;
       int cbind;
       unsigned short *cindex;
       pfFog *fog;
       int fogEnabled = 0;
       int i,n;

       int sizeMode;

       pfMatrix ViewMat, InvModelView;

            /* get pointers to the geoset */
            pfGetGSetAttrLists(rasterData-&gt;gset,PFGS_COORD3, &amp;vertices, &amp;vindex);
            pfGetGSetAttrLists(rasterData-&gt;gset,PFGS_NORMAL3, &amp;norms, &amp;nindex);
            nbind = pfGetGSetAttrBind(rasterData-&gt;gset,PFGS_NORMAL3);
            /* colors are usualy not used here */
            cbind = pfGetGSetAttrBind(rasterData-&gt;gset,PFGS_COLOR4);
            pfGetGSetAttrLists(rasterData-&gt;gset,PFGS_COLOR4, &amp;colors, &amp;cindex);
            /* use color table if enabled */
            if (pfGetEnable(PFEN_COLORTABLE))
                 colors = pfGetCurCtab();
            /* get the number of lights */
            n = pfGetGSetNumPrims(rasterData-&gt;gset);

            /* get matrices */
            pfGetViewMat(ViewMat);
            pfGetInvModelMat(InvModelMat);

            /* see if there's fog */
            ........
            /* do the computation */
            for (i=0; i&lt;n; i++)
            {
               /* get the normal */
               if (vindex)
               {
                  if (nbind &amp; PFGS_OVERALL)
                   nj=nindex[0];
                  else if (nbind)
                      nj=nindex[i];
                  else
                   nj=-1; /* this geoset has no normals */

                  nv=vindex[i];
               } else
               {
                  if (nbind &amp; PFGS_OVERALL)
                      nj=0;
                     else if (nbind)
                   nj=i;
                  else
                   nj=-1; /* this geoset has no normals */

                  nv=i;
               }
               /* now we have vertices[nv] and normals[nv] to do the computation */

               ........
               ........
               rasterData-&gt;alphas[i] = ....
               rasterData-&gt;sizes[i] = ....
               }
       }


       <B>Calligraphic</B> Light Points are supported using the prepro-
       cessing capability, and the pfCalligraphic object. The
       calligraphic extensions to pfLPointState are described in
       the pfCalligraphic man pages.



</PRE>
<H2>NOTES</H2><PRE>
       Falloff distribution is cosine(incidence angle) ^ falloff.

       The angle calculation for textured lightpoints may be
       inaccurate in extreme wide-angle visibility configura-
       tions, and work only for symmetric aperture.



</PRE>
<H2>SEE ALSO</H2><PRE>
       pfCalligraphic, pfDelete, pfDispList, pfFog, pfGeoSet,
       pfGeoState, pfState, pfTexture, pfTexGen, pfuMakeLPStat-
       eRangeTex, pfuMakeLPStateShapeTex



                                               pfLPointState(3pf)
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
