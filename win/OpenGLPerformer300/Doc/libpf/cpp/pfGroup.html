<HTML>
<HEAD>
<TITLE>pfGroup</TITLE>
</HEAD>
<BODY>
<H1>pfGroup</H1>
<HR>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->
pfGroup(3pf)                                         pfGroup(3pf)




</PRE>
<H2>NAME</H2><PRE>
       <B>pfGroup</B> - Create, modify, and query a group node.


</PRE>
<H2>FUNCTION SPECIFICATION</H2><PRE>
       #include &lt;Performer/pf/pfGroup.h&gt;

                         <B>pfGroup::pfGroup</B>();

       static pfType *   <B>pfGroup::getClassType</B>(void);

       int               <B>pfGroup::addChild</B>(pfNode *child);

       int               <B>pfGroup::insertChild</B>(int index,     pfN-
                           ode *child);

       int               <B>pfGroup::replaceChild</B>(pfNode *old,  pfN-
                           ode *new);

       int               <B>pfGroup::removeChild</B>(pfNode* child);

       int               <B>pfGroup::searchChild</B>(pfNode* child);

       pfNode *          <B>pfGroup::getChild</B>(int index);

       int               <B>pfGroup::getNumChildren</B>(void);

       int               <B>pfGroup::bufferAddChild</B>(pfNode *child);

       int               <B>pfGroup::bufferRemoveChild</B>(pfNode *child);


</PRE>
<H2>PARENT CLASS FUNCTIONS</H2><PRE>
       The OpenGL Performer class <B>pfGroup</B>  is  derived  from  the
       parent  class <B>pfNode</B>, so each of these member functions of
       class <B>pfNode</B> are also  directly  usable  with  objects  of
       class  <B>pfGroup</B>.  This is also true for ancestor classes of
       class <B>pfNode</B>.

       pfGroup *      <B>pfNode::getParent</B>(int i);
       int            <B>pfNode::getNumParents</B>(void);
       void           <B>pfNode::setBound</B>(pfSphere *bsph, int mode);
       int            <B>pfNode::getBound</B>(pfSphere *bsph);
       pfNode*        <B>pfNode::clone</B>(int mode);
       pfNode*        <B>pfNode::bufferClone</B>(int mode,
                        pfBuffer *buf);
       int            <B>pfNode::flatten</B>(int mode);
       int            <B>pfNode::setName</B>(const char *name);
       const char *   <B>pfNode::getName</B>(void);
       pfNode*        <B>pfNode::find</B>(const char *pathName,
                        pfType *type);
       pfNode*        <B>pfNode::lookup</B>(const char *name,
                        pfType* type);
       int            <B>pfNode::isect</B>(pfSegSet *segSet,
                        pfHit **hits[]);
       void           <B>pfNode::setTravMask</B>(int which,   uint mask,
                        int setMode, int bitOp);

       void *         <B>pfNode::getTravData</B>(int which);
       void           <B>pfNode::setTravMode</B>(int which,    int mode,
                        int val);
       int            <B>pfNode::getTravMode</B>(int which,
                        int mode) const;


       Since  the  class <B>pfNode</B> is itself derived from the parent
       class <B>pfObject</B>, objects of class <B>pfGroup</B> can also be  used
       with   these  functions  designed  for  objects  of  class
       <B>pfObject</B>.

       void*   <B>pfObject::operator</B> <B>new</B>(size_t);
       void*   <B>pfObject::operator</B> <B>new</B>(size_t, void *arena);
       void*   <B>pfObject::operator</B>     <B>new</B>(size_t,      pfFluxMem-
                 ory *fmem);
       void    <B>pfObject::setUserData</B>(void *data);
       void    <B>pfObject::setUserData</B>(int slot, void *data);
       void*   <B>pfObject::getUserData</B>(pfObject *obj);
       void*   <B>pfObject::getUserData</B>(pfObject *obj, int slot);
       int     <B>pfObject::getNumUserData</B>();


       Since the class <B>pfObject</B> is itself derived from the parent
       class <B>pfMemory</B>, objects of class <B>pfGroup</B> can also be  used
       with   these  functions  designed  for  objects  of  class
       <B>pfMemory</B>.

       void*          <B>pfMemory::getData</B>(const void *ptr);
       pfType *       <B>pfMemory::getType</B>();
       int            <B>pfMemory::isOfType</B>(pfType *type);
       int            <B>pfMemory::isExactType</B>(pfType *type);
       const char *   <B>pfMemory::getTypeName</B>();
       int            <B>pfMemory::copy</B>(pfMemory *src);
       int            <B>pfMemory::compare</B>(const pfMemory *mem);
       void           <B>pfMemory::print</B>(uint which,   uint verbose,
                        char *prefix, FILE *file);
       int            <B>pfMemory::getArena</B>(void *ptr);
       void*          <B>pfMemory::getArena</B>();
       int            <B>pfMemory::ref</B>();
       int            <B>pfMemory::unref</B>();
       int            <B>pfMemory::unrefDelete</B>();
       int            <B>pfMemory::unrefGetRef</B>();
       int            <B>pfMemory::getRef</B>();
       int            <B>pfMemory::checkDelete</B>();
       int            <B>pfMemory::isFluxed</B>();
       void *         <B>pfMemory::getArena</B>();
       int            <B>pfMemory::getSize</B>();


</PRE>
<H2>PARAMETERS</H2><PRE>
       <I>group</I>  identifies a pfGroup.


</PRE>
<H2>DESCRIPTION</H2><PRE>
       A  pfGroup  is  the  internal node type of the OpenGL Per-
       former hierarchy and is derived from  pfNode.   A  pfGroup
       has  a  list of children which are traversed when <I>group</I> is
       traversed.  Children may be any pfNode which includes both
       internal nodes (pfGroups) and leaf nodes (pfNodes).  Other
       nodes which are derived from pfGroup may use pfGroup  API.
              <B>pfDCS</B>
              <B>pfMorph</B>

       <B>new</B>  <B>pfGroup</B>  creates  and  returns a handle to a pfGroup.
       Like other pfNodes, pfGroups  are  always  allocated  from
       shared  memory  and  cannot  be created statically, on the
       stack or in arrays.   pfGroups  should  be  deleted  using
       <B>pfDelete</B> rather than the delete operator.

       <B>pfGroup::getClassType</B>  returns  the  <B>pfType</B>* for the class
       <B>pfGroup</B>.  The <B>pfType</B>* returned by <B>pfGroup::getClassType</B> is
       the  same  as the <B>pfType</B>* returned by invoking the virtual
       function  <B>getType</B>  on  any  instance  of  class   <B>pfGroup</B>.
       Because  OpenGL  Performer  allows subclassing of built-in
       types, when decisions are made based on  the  type  of  an
       object,  it  is usually better to use  the member function
       <B>isOfType</B> to test if an object is of a type derived from  a
       Performer  type rather than to test for strict equality of
       the <B>pfType</B>*'s.

       <B>pfGroup::addChild</B> appends <I>child</I> to the pfGroup and  incre-
       ments  the reference count of <I>child</I>.  <B>pfGroup::removeChild</B>
       removes <I>child</I> from the list and shifts the list down  over
       the vacant spot, e.g. - if <I>child</I> had index 0, then index 1
       becomes index 0, index  2  becomes  index  1  and  so  on.
       <B>pfGroup::removeChild</B>  returns  a  1  if <I>child</I> was actually
       removed  and  0  if  it  was  not  found  in   the   list.
       <B>pfGroup::removeChild</B>  decrements  the  reference  count of
       <I>child</I> but does not delete <I>child</I>  if  its  reference  count
       reaches 0.

       <B>pfGroup::insertChild</B>  inserts  <I>child</I> before the child with
       index  <I>index</I>.   <I>index</I>  must  be  within  the  range  0  to
       <B>pfGroup::getNumChildren</B>().

       <B>pfGroup::replaceChild</B>  replaces <I>old</I> with <I>new</I> and returns 1
       if the operation was successful or 0 if <I>old</I> is not a child
       of the pfGroup.

       <B>pfGroup::searchChild</B>  returns the index of <I>child</I> if it was
       found in the children list of the pfGroup or -1 if it  was
       not found.

       <B>pfGroup::getNumChildren</B>  returns the number of children in
       the pfGroup.  <B>pfGroup::getChild</B> returns a  handle  to  the
       child  with  index  <I>index</I>  or  NULL if the index is out of
       range.

       The bounding volume of a pfGroup encompasses all its chil-
       dren.   Modifications  to the child list of a pfGroup will
       cause OpenGL Performer to recompute new  bounding  volumes
       for  the  pfGroup  unless  it  is configured to use static
       bounding volumes (see <B>pfNode::setBound</B>).

       <B>pfGroup::bufferAddChild</B>   and   <B>pfGroup::bufferRemoveChild</B>
       provide  access  to nodes that do not exist in the current
       pfBuffer (See the pfBuffer man  page).  Either,  none,  or
       both  of  the pfBuffer and <I>node</I> may exist outside the cur-
       rent      pfBuffer.       <B>pfGroup::bufferAddChild</B>      and
       list        of         <B>pfGroup::bufferAddChild</B>         and
       <B>pfGroup::bufferRemoveChild</B>   requests   is   traversed  in
       <B>pfBuffer::merge</B>  after  all  nodes   have   been   merged.
       <B>pfGroup::bufferAddChild</B>   and   <B>pfGroup::bufferRemoveChild</B>
       return <B>TRUE</B> if the request was recorded and  <B>FALSE</B>  other-
       wise.



</PRE>
<H2>SEE ALSO</H2><PRE>
       pfNode, pfBuffer, pfDelete



                                                     pfGroup(3pf)
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
