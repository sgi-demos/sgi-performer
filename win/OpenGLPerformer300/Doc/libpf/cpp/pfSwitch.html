<HTML>
<HEAD>
<TITLE>pfSwitch</TITLE>
</HEAD>
<BODY>
<H1>pfSwitch</H1>
<HR>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->
pfSwitch(3pf)                                       pfSwitch(3pf)




</PRE>
<H2>NAME</H2><PRE>
       <B>pfSwitch</B> - Create, modify, and query a switch node.


</PRE>
<H2>FUNCTION SPECIFICATION</H2><PRE>
       #include &lt;Performer/pf/pfSwitch.h&gt;

                         <B>pfSwitch::pfSwitch</B>();

       static pfType *   <B>pfSwitch::getClassType</B>(void);

       int               <B>pfSwitch::setVal</B>(float val);

       float             <B>pfSwitch::getVal</B>(void);

       int               <B>pfSwitch::setValFlux</B>(pfFlux *flux);

       pfFlux *          <B>pfSwitch::getValFlux</B>(void);


</PRE>
<H2>PARENT CLASS FUNCTIONS</H2><PRE>
       The  OpenGL  Performer  class <B>pfSwitch</B> is derived from the
       parent class <B>pfGroup</B>, so each of these member functions of
       class  <B>pfGroup</B>  are  also  directly usable with objects of
       class <B>pfSwitch</B>.  This is also true for ancestor classes of
       class <B>pfGroup</B>.

       int        <B>pfGroup::addChild</B>(pfNode *child);
       int        <B>pfGroup::insertChild</B>(int index, pfNode *child);
       int        <B>pfGroup::replaceChild</B>(pfNode *old,         pfN-
                    ode *new);
       int        <B>pfGroup::removeChild</B>(pfNode* child);
       int        <B>pfGroup::searchChild</B>(pfNode* child);
       pfNode *   <B>pfGroup::getChild</B>(int index);
       int        <B>pfGroup::getNumChildren</B>(void);
       int        <B>pfGroup::bufferAddChild</B>(pfNode *child);
       int        <B>pfGroup::bufferRemoveChild</B>(pfNode *child);


       Since  the class <B>pfGroup</B> is itself derived from the parent
       class <B>pfNode</B>, objects of class <B>pfSwitch</B> can also  be  used
       with these functions designed for objects of class <B>pfNode</B>.

       pfGroup *      <B>pfNode::getParent</B>(int i);
       int            <B>pfNode::getNumParents</B>(void);
       void           <B>pfNode::setBound</B>(pfSphere *bsph, int mode);
       int            <B>pfNode::getBound</B>(pfSphere *bsph);
       pfNode*        <B>pfNode::clone</B>(int mode);
       pfNode*        <B>pfNode::bufferClone</B>(int mode,
                        pfBuffer *buf);
       int            <B>pfNode::flatten</B>(int mode);
       int            <B>pfNode::setName</B>(const char *name);
       const char *   <B>pfNode::getName</B>(void);
       pfNode*        <B>pfNode::find</B>(const char *pathName,
                        pfType *type);
       pfNode*        <B>pfNode::lookup</B>(const char *name,
                        pfType* type);

       void           <B>pfNode::getTravFuncs</B>(int which, pfNodeTrav-
                        FuncType *pre,          pfNodeTravFunc-
                        Type *post);
       void           <B>pfNode::setTravData</B>(int which, void *data);
       void *         <B>pfNode::getTravData</B>(int which);
       void           <B>pfNode::setTravMode</B>(int which,    int mode,
                        int val);
       int            <B>pfNode::getTravMode</B>(int which,
                        int mode) const;


       Since  the  class <B>pfNode</B> is itself derived from the parent
       class <B>pfObject</B>, objects of class <B>pfSwitch</B> can also be used
       with   these  functions  designed  for  objects  of  class
       <B>pfObject</B>.

       void*   <B>pfObject::operator</B> <B>new</B>(size_t);
       void*   <B>pfObject::operator</B> <B>new</B>(size_t, void *arena);
       void*   <B>pfObject::operator</B>     <B>new</B>(size_t,      pfFluxMem-
                 ory *fmem);
       void    <B>pfObject::setUserData</B>(void *data);
       void    <B>pfObject::setUserData</B>(int slot, void *data);
       void*   <B>pfObject::getUserData</B>(pfObject *obj);
       void*   <B>pfObject::getUserData</B>(pfObject *obj, int slot);
       int     <B>pfObject::getNumUserData</B>();


       Since the class <B>pfObject</B> is itself derived from the parent
       class <B>pfMemory</B>, objects of class <B>pfSwitch</B> can also be used
       with   these  functions  designed  for  objects  of  class
       <B>pfMemory</B>.

       void*          <B>pfMemory::getData</B>(const void *ptr);
       pfType *       <B>pfMemory::getType</B>();
       int            <B>pfMemory::isOfType</B>(pfType *type);
       int            <B>pfMemory::isExactType</B>(pfType *type);
       const char *   <B>pfMemory::getTypeName</B>();
       int            <B>pfMemory::copy</B>(pfMemory *src);
       int            <B>pfMemory::compare</B>(const pfMemory *mem);
       void           <B>pfMemory::print</B>(uint which,   uint verbose,
                        char *prefix, FILE *file);
       int            <B>pfMemory::getArena</B>(void *ptr);
       void*          <B>pfMemory::getArena</B>();
       int            <B>pfMemory::ref</B>();
       int            <B>pfMemory::unref</B>();
       int            <B>pfMemory::unrefDelete</B>();
       int            <B>pfMemory::unrefGetRef</B>();
       int            <B>pfMemory::getRef</B>();
       int            <B>pfMemory::checkDelete</B>();
       int            <B>pfMemory::isFluxed</B>();
       void *         <B>pfMemory::getArena</B>();
       int            <B>pfMemory::getSize</B>();


</PRE>
<H2>DESCRIPTION</H2><PRE>
       A  pfSwitch  is  an  interior node in the OpenGL Performer
       node hierarchy that selects one, all, or none of its chil-
       dren.   It  is  derived from pfGroup so it can use pfGroup
       API to manipulate its child list.

       <B>pfSwitch</B>.   The <B>pfType</B>* returned by <B>pfSwitch::getClassType</B>
       is the same as the <B>pfType</B>* returned by invoking  the  vir-
       tual  function  <B>getType</B> on any instance of class <B>pfSwitch</B>.
       Because OpenGL Performer allows  subclassing  of  built-in
       types,  when  decisions  are  made based on the type of an
       object, it is usually better to use  the  member  function
       <B>isOfType</B>  to test if an object is of a type derived from a
       Performer type rather than to test for strict equality  of
       the <B>pfType</B>*'s.

       <B>pfSwitch::setVal</B>  sets the switch value of the pfSwitch to
       <I>val</I>.  <I>val</I> may be a float ranging from  0  to  N-1  with  N
       being  the number of children of the pfSwitch or it may be
       a symbolic token: <B>PFSWITCH_ON</B>  or  <B>PFSWITCH_OFF</B>  in  which
       case  all  children or no children are selected.  <B>pfSwitch</B>
       uses the integer portion of <I>val</I>. <B>pfSwitch::getVal</B>  returns
       the current switch value.

       The  validity of the switch value delayed until the switch
       is actually evaluated (usually  by  a  traversal  such  as
       CULL). For example, it is legal to set a switch value of 2
       on a pfSwitch node with no children, provided at  least  2
       children are added before the pfSwitch is evaluated.

       <B>pfSwitch::setValFlux</B>  and <B>pfSwitch::getValFlux</B> set and get
       a pfFlux to be used for controling a pfSwitch.  This is an
       alternate  method  of  contoling a pfSwitch.  If the value
       flux of a pfSwitch is <B>NULL</B>, the switch will be  contorlled
       by  the  value  set  with  <B>pfSwitch::setVal</B>.  A value flux
       should contain a single float.  The integer portion of the
       float will be used to select the switch setting.

       Calling  <B>pfSwitch::setVal</B>  on  a  pfSwitch with a non <B>NULL</B>
       value   flux   will   set   the   value   flux.    Calling
       <B>pfSwitch::getVal</B>  on a pfSwitch with a non <B>NULL</B> value flux
       will return the current data of the value flux.



</PRE>
<H2>NOTES</H2><PRE>
       <B>PF_ON</B>   and   <B>PF_OFF</B>   tokens   will   NOT    work    with
       <B>pfSwitch::setVal</B>.


</PRE>
<H2>SEE ALSO</H2><PRE>
       pfGroup, pfNode, pfScene, pfDelete



                                                    pfSwitch(3pf)
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
