<HTML>
<HEAD>
<TITLE>pfPartition</TITLE>
</HEAD>
<BODY>
<H1>pfPartition</H1>
<HR>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->
pfPartition(3pf)                                 pfPartition(3pf)




</PRE>
<H2>NAME</H2><PRE>
       <B>pfPartition</B> - Create and update pfPartition spatial parti-
       tioning node.


</PRE>
<H2>FUNCTION SPECIFICATION</H2><PRE>
       #include &lt;Performer/pf/pfPartition.h&gt;

                         <B>pfPartition::pfPartition</B>();

       static pfType *   <B>pfPartition::getClassType</B>(void);

       void              <B>pfPartition::setVal</B>(int which,
                           float val);

       float             <B>pfPartition::getVal</B>(int which);

       void              <B>pfPartition::setAttr</B>(int which,
                           void *attr);

       void*             <B>pfPartition::getAttr</B>(int which);

       void              <B>pfPartition::build</B>();

       void              <B>pfPartition::update</B>(void);


</PRE>
<H2>PARENT CLASS FUNCTIONS</H2><PRE>
       The OpenGL Performer class <B>pfPartition</B> is derived from the
       parent class <B>pfGroup</B>, so each of these member functions of
       class <B>pfGroup</B> are also directly  usable  with  objects  of
       class <B>pfPartition</B>.  This is also true for ancestor classes
       of class <B>pfGroup</B>.

       int        <B>pfGroup::addChild</B>(pfNode *child);
       int        <B>pfGroup::insertChild</B>(int index, pfNode *child);
       int        <B>pfGroup::replaceChild</B>(pfNode *old,         pfN-
                    ode *new);
       int        <B>pfGroup::removeChild</B>(pfNode* child);
       int        <B>pfGroup::searchChild</B>(pfNode* child);
       pfNode *   <B>pfGroup::getChild</B>(int index);
       int        <B>pfGroup::getNumChildren</B>(void);
       int        <B>pfGroup::bufferAddChild</B>(pfNode *child);
       int        <B>pfGroup::bufferRemoveChild</B>(pfNode *child);


       Since the class <B>pfGroup</B> is itself derived from the  parent
       class  <B>pfNode</B>,  objects  of  class <B>pfPartition</B> can also be
       used with these functions designed for  objects  of  class
       <B>pfNode</B>.

       pfGroup *      <B>pfNode::getParent</B>(int i);
       int            <B>pfNode::getNumParents</B>(void);
       void           <B>pfNode::setBound</B>(pfSphere *bsph, int mode);
       int            <B>pfNode::getBound</B>(pfSphere *bsph);
       pfNode*        <B>pfNode::clone</B>(int mode);
       pfNode*        <B>pfNode::bufferClone</B>(int mode,
                        pfType* type);
       int            <B>pfNode::isect</B>(pfSegSet *segSet,
                        pfHit **hits[]);
       void           <B>pfNode::setTravMask</B>(int which,   uint mask,
                        int setMode, int bitOp);
       uint           <B>pfNode::getTravMask</B>(int which);
       void           <B>pfNode::setTravFuncs</B>(int which, pfNodeTrav-
                        FuncType pre, pfNodeTravFuncType post);
       void           <B>pfNode::getTravFuncs</B>(int which, pfNodeTrav-
                        FuncType *pre,          pfNodeTravFunc-
                        Type *post);
       void           <B>pfNode::setTravData</B>(int which, void *data);
       void *         <B>pfNode::getTravData</B>(int which);
       void           <B>pfNode::setTravMode</B>(int which,    int mode,
                        int val);
       int            <B>pfNode::getTravMode</B>(int which,
                        int mode) const;


       Since the class <B>pfNode</B> is itself derived from  the  parent
       class  <B>pfObject</B>,  objects of class <B>pfPartition</B> can also be
       used with these functions designed for  objects  of  class
       <B>pfObject</B>.

       void*   <B>pfObject::operator</B> <B>new</B>(size_t);
       void*   <B>pfObject::operator</B> <B>new</B>(size_t, void *arena);
       void*   <B>pfObject::operator</B>      <B>new</B>(size_t,     pfFluxMem-
                 ory *fmem);
       void    <B>pfObject::setUserData</B>(void *data);
       void    <B>pfObject::setUserData</B>(int slot, void *data);
       void*   <B>pfObject::getUserData</B>(pfObject *obj);
       void*   <B>pfObject::getUserData</B>(pfObject *obj, int slot);
       int     <B>pfObject::getNumUserData</B>();


       Since the class <B>pfObject</B> is itself derived from the parent
       class  <B>pfMemory</B>,  objects of class <B>pfPartition</B> can also be
       used with these functions designed for  objects  of  class
       <B>pfMemory</B>.

       void*          <B>pfMemory::getData</B>(const void *ptr);
       pfType *       <B>pfMemory::getType</B>();
       int            <B>pfMemory::isOfType</B>(pfType *type);
       int            <B>pfMemory::isExactType</B>(pfType *type);
       const char *   <B>pfMemory::getTypeName</B>();
       int            <B>pfMemory::copy</B>(pfMemory *src);
       int            <B>pfMemory::compare</B>(const pfMemory *mem);
       void           <B>pfMemory::print</B>(uint which,   uint verbose,
                        char *prefix, FILE *file);
       int            <B>pfMemory::getArena</B>(void *ptr);
       void*          <B>pfMemory::getArena</B>();
       int            <B>pfMemory::ref</B>();
       int            <B>pfMemory::unref</B>();
       int            <B>pfMemory::unrefDelete</B>();
       int            <B>pfMemory::unrefGetRef</B>();
       int            <B>pfMemory::getRef</B>();
       int            <B>pfMemory::checkDelete</B>();
       int            <B>pfMemory::isFluxed</B>();
       void *         <B>pfMemory::getArena</B>();
       affect culling performance nor does it  improve  intersec-
       tion  performance  under  transformation  nodes,  pfSwitch
       nodes, pfMorph nodes or pfSequence nodes.

       <B>new</B> <B>pfPartition</B> creates and returns a handle to a pfParti-
       tion.   Like  other pfNodes, pfPartitions are always allo-
       cated from shared memory and cannot be created statically,
       on the stack or in arrays.  pfPartitions should be deleted
       using <B>pfDelete</B> rather than the delete operator.

       <B>pfPartition::getClassType</B>  returns  the  <B>pfType</B>*  for  the
       class    <B>pfPartition</B>.     The    <B>pfType</B>*    returned    by
       <B>pfPartition::getClassType</B>  is  the  same  as  the  <B>pfType</B>*
       returned  by  invoking the virtual function <B>getType</B> on any
       instance of class <B>pfPartition</B>.  Because  OpenGL  Performer
       allows  subclassing  of built-in types, when decisions are
       made based on the type of an object, it is usually  better
       to  use  the member function <B>isOfType</B> to test if an object
       is of a type derived from a Performer type rather than  to
       test for strict equality of the <B>pfType</B>*'s.

       <B>pfPartition::build</B>  constructs  a  2D spatial partitioning
       based on the <I>type</I>.

       Within   the   confines   of   the   parameters   set   by
       <B>pfPartition::setAttr</B>,  OpenGL  Performer  attempts to con-
       struct an optimal partition based on the  distribution  of
       vertices within the pfGeoSets in the subgraph of the scene
       rooted at the partition.  Information about  the  selected
       partitioning  is displayed when the <B>pfNotifyLevel</B> is debug
       or higher.  Because the search for the optimal  partition-
       ing  is  compute intensive, once the partitioning has been
       determined for a particular database,  the  range  of  the
       search should be restricted using <B>pfPartition::setAttr</B>.

       <B>pfPartition::update</B>  causes the scene graph under the par-
       tition to be traversed and any changes  incorporated  into
       the  spatial  partitioning.   The partitioning itself does
       not change.

       <B>pfPartition::setAttr</B> sets the partition attribute <I>attr</I>  to
       the attribute <I>attr</I>.  Partition attributes are:

              <B>PFPART_MIN_SPACING</B>
                   <I>attr</I> points to a pfVec3 specifying the minimum
                   spacing between  partition  dividers  in  each
                   dimension.   If  not specified, the default is
                   1/20th of the bounding box diagonal.   When  a
                   partition  is  built, a search is made between
                   <B>PFPART_MAX_SPACING</B> and <B>PFPART_MIN_SPACING</B>.

              <B>PFPART_MAX_SPACING</B>
                   <I>attr</I> points to a pfVec3 specifying the maximum
                   spacing  between  partition  dividers  in each
                   dimension.  If not specified, the  default  is
                   1/10th  of  the bounding box diagonal.  When a
                   partition is built, a search is  made  between
                   <B>PFPART_MAX_SPACING</B> and <B>PFPART_MIN_SPACING</B>.

       <B>pfPartition::setVal</B> sets the partition value  <I>val</I>  to  the
       value <I>val</I>.  Partition values are:

              <B>PFPART_FINENESS</B>
                   A  value  between  0.0 and 1.0 which indicates
                   how fine of  a  partitioning  should  be  con-
                   structed.    The  subdivision  is  limited  by
                   <B>PFPART_MIN_SPACING</B>   and   <B>PFPART_MAX_SPACING</B>.
                   1.0  causes  extremely  fine subdivision.  0.0
                   causes no subdivision.  0.5 is usually a  good
                   value and is the default.

       <B>pfPartition::getVal</B> returns the partition value <I>val</I>.

       A  pfPartition behaves like a pfGroup when the mode in the
       pfSegSet    used     with     <B>pfNodeIsectSegs</B>     includes
       <B>PFTRAV_IS_NO_PART</B>.



</PRE>
<H2>NOTES</H2><PRE>
       pfPartitions are primarily useful for databases containing
       many axis-aligned objects for which bounding spheres are a
       poor  fit  and  when only one or two segments are made per
       call to <B>pfNodeIsectSegs</B>.  For example,  terrain  following
       on  gridded  terrain  is likely to benefit.  For databases
       such as this which themselves have a regular grid,  it  is
       also important for performance that the origin and spacing
       of the partition align exactly the terrain grid.  pfParti-
       tions  do  not  currently  help with the problem pfGeoSets
       containing too much geometry.



</PRE>
<H2>BUGS</H2><PRE>
       The search for an optimal grid is very thorough so that it
       takes  a  <I>very</I>  long  time  if the search domain is large.
       Once a good partitioning for a database is determined, the
       <B>PFPART_MIN_SPACING</B>,  <B>PFPART_MAX_SPACING</B>  and <B>PFPART_ORIGIN</B>
       can be set equal for much faster building.

       Currently only partitionings in  the  XY  plane  are  sup-
       ported.



</PRE>
<H2>SEE ALSO</H2><PRE>
       pfGroup, pfNode, pfNodeIsectSegs, pfNotifyLevel, pfScene



                                                 pfPartition(3pf)
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
