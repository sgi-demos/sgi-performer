<HTML>
<HEAD>
<TITLE>pfSequence</TITLE>
</HEAD>
<BODY>
<H1>pfSequence</H1>
<HR>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->
pfSequence(3pf)                                   pfSequence(3pf)




</PRE>
<H2>NAME</H2><PRE>
       <B>pfNewSeq,</B>   <B>pfGetSeqClassType,</B>   <B>pfSeqTime,</B>  <B>pfGetSeqTime,</B>
       <B>pfSeqInterval,</B> <B>pfGetSeqInterval,</B> <B>pfSeqDuration,</B>  <B>pfGetSeq-</B>
       <B>Duration,</B>  <B>pfSeqMode,</B> <B>pfGetSeqMode,</B> <B>pfGetSeqFrame,</B> <B>pfSeqE-</B>
       <B>valuation,</B> <B>pfGetSeqEvaluation</B> - Control animation sequence
       nodes.


</PRE>
<H2>FUNCTION SPECIFICATION</H2><PRE>
       #include &lt;Performer/pf.h&gt;

       pfSequence *   <B>pfNewSeq</B>(void);

       pfType *       <B>pfGetSeqClassType</B>(void);

       void           <B>pfSeqTime</B>(pfSequence *seq,  int frame, dou-
                        ble time);

       double         <B>pfGetSeqTime</B>(const pfSequence *seq,
                        int frame);

       void           <B>pfSeqInterval</B>(pfSequence *seq,    int mode,
                        int begin, int end);

       void           <B>pfGetSeqInterval</B>(const pfSequence *seq,
                        int *mode, int *begin, int *end);

       void           <B>pfSeqDuration</B>(pfSequence *seq, float speed,
                        int nReps);

       void           <B>pfGetSeqDuration</B>(const pfSequence *seq,
                        float *speed, int *nReps);

       void           <B>pfSeqMode</B>(pfSequence *seq, int mode);

       int            <B>pfGetSeqMode</B>(const pfSequence *seq);

       int            <B>pfGetSeqFrame</B>(const pfSequence *seq,
                        int *repeat);

       void           <B>pfSeqEvaluation</B>(const pfSequence *seq,
                        int state);

       int            <B>pfGetSeqEvaluation</B>(const pfSequence *seq);


</PRE>
<H2>PARENT CLASS FUNCTIONS</H2><PRE>
       The  OpenGL Performer class <B>pfSequence</B> is derived from the
       parent class <B>pfGroup</B>, so each of these member functions of
       class  <B>pfGroup</B>  are  also  directly usable with objects of
       class <B>pfSequence</B>.  Casting an object of  class  <B>pfSequence</B>
       to  an  object of class <B>pfGroup</B> is taken care of automati-
       cally.  This is also true for casts to objects of ancestor
       classes of class <B>pfGroup</B>.

       int        <B>pfAddChild</B>(pfGroup *group, pfNode *child);
       int        <B>pfInsertChild</B>(pfGroup *group,  int index,  pfN-
       int        <B>pfBufferAddChild</B>(pfGroup *group,           pfN-
                    ode *child);
       int        <B>pfBufferRemoveChild</B>(pfGroup *group,        pfN-
                    ode *child);


       Since  the class <B>pfGroup</B> is itself derived from the parent
       class <B>pfNode</B>, objects of class <B>pfSequence</B> can also be used
       with these functions designed for objects of class <B>pfNode</B>.

       pfGroup *      <B>pfGetParent</B>(const pfNode *node, int i);
       int            <B>pfGetNumParents</B>(const pfNode *node);
       void           <B>pfNodeBSphere</B>(pfNode *node, pfSphere *bsph,
                        int mode);
       int            <B>pfGetNodeBSphere</B>(pfNode *node,
                        pfSphere *bsph);
       pfNode*        <B>pfClone</B>(pfNode *node, int mode);
       pfNode*        <B>pfBufferClone</B>(pfNode *node,       int mode,
                        pfBuffer *buf);
       int            <B>pfFlatten</B>(pfNode *node, int mode);
       int            <B>pfNodeName</B>(pfNode *node, const char *name);
       const char *   <B>pfGetNodeName</B>(const pfNode *node);
       pfNode*        <B>pfFindNode</B>(pfNode *node,  const char *path-
                        Name, pfType *type);
       pfNode*        <B>pfLookupNode</B>(const char *name,
                        pfType* type);
       int            <B>pfNodeIsectSegs</B>(pfNode *node,
                        pfSegSet *segSet, pfHit **hits[]);
       void           <B>pfNodeTravMask</B>(pfNode *node,     int which,
                        uint mask, int setMode, int bitOp);
       uint           <B>pfGetNodeTravMask</B>(const pfNode *node,
                        int which);
       void           <B>pfNodeTravFuncs</B>(pfNode* node,    int which,
                        pfNodeTravFuncType pre, pfNodeTravFunc-
                        Type post);
       void           <B>pfGetNodeTravFuncs</B>(const pfNode* node,
                        int which,     pfNodeTravFuncType *pre,
                        pfNodeTravFuncType *post);
       void           <B>pfNodeTravData</B>(pfNode *node,     int which,
                        void *data);
       void *         <B>pfGetNodeTravData</B>(const pfNode *node,
                        int which);
       void           <B>pfNodeTravMode</B>(pfNode* node,     int which,
                        int mode, int val);
       int            <B>pfGetNodeTravMode</B>(const pfNode* node,
                        int which, int mode);


       Since  the  class <B>pfNode</B> is itself derived from the parent
       class <B>pfObject</B>, objects of class <B>pfSequence</B>  can  also  be
       used  with  these  functions designed for objects of class
       <B>pfObject</B>.

       void          <B>pfUserDataSlot</B>(pfObject *obj,      int slot,
                       void *data);
       void          <B>pfUserData</B>(pfObject *obj, void *data);
       void*         <B>pfGetUserDataSlot</B>(pfObject *obj, int slot);
       void*         <B>pfGetUserData</B>(pfObject *obj);
       int           <B>pfGetNumUserData</B>(pfObject *obj);
       Since the class <B>pfObject</B> is itself derived from the parent
       class <B>pfMemory</B>, objects of class <B>pfSequence</B>  can  also  be
       used  with  these  functions designed for objects of class
       <B>pfMemory</B>.

       pfType *       <B>pfGetType</B>(const void *ptr);
       int            <B>pfIsOfType</B>(const void *ptr, pfType *type);
       int            <B>pfIsExactType</B>(const void *ptr,
                        pfType *type);
       const char *   <B>pfGetTypeName</B>(const void *ptr);
       int            <B>pfRef</B>(void *ptr);
       int            <B>pfUnref</B>(void *ptr);
       int            <B>pfUnrefDelete</B>(void *ptr);
       int            <B>pfUnrefGetRef</B>(void *ptr);
       int            <B>pfGetRef</B>(const void *ptr);
       int            <B>pfCopy</B>(void *dst, void *src);
       int            <B>pfDelete</B>(void *ptr);
       int            <B>pfIsFluxed</B>(void *ptr);
       int            <B>pfCompare</B>(const void *ptr1,
                        const void *ptr2);
       void           <B>pfPrint</B>(const void *ptr,        uint which,
                        uint verbose, FILE *file);
       void *         <B>pfGetArena</B>(void *ptr);


</PRE>
<H2>PARAMETERS</H2><PRE>
       <I>seq</I>  identifies a pfSequence.


</PRE>
<H2>DESCRIPTION</H2><PRE>
       A  pfSequence  is a pfGroup that sequences through a range
       of its children, drawing each child for a  certain  length
       of  time.   Its  primary  use  is  for animations, where a
       <I>sequence</I> of objects or  geometry  (children)  represent  a
       desired visual event.  <B>pfNewSeq</B> creates and returns a han-
       dle to a pfSequence.  Like other pfNodes, pfSequences  are
       always  allocated  from  shared  memory and can be deleted
       using <B>pfDelete</B>.

       <B>pfGetSeqClassType</B>  returns  the  <B>pfType</B>*  for  the   class
       <B>pfSequence</B>.   The <B>pfType</B>* returned by <B>pfGetSeqClassType</B> is
       the same as the <B>pfType</B>* returned by invoking <B>pfGetType</B>  on
       any  instance  of  class  <B>pfSequence</B>.  Because OpenGL Per-
       former allows subclassing of built-in  types,  when  deci-
       sions  are made based on the type of an object, it is usu-
       ally better to use <B>pfIsOfType</B> to test if an object is of a
       type derived from a Performer type rather than to test for
       strict equality of the <B>pfType</B>*'s.

       Children are added to a pfSequence  using  normal  pfGroup
       API  (<B>pfAddChild</B>).   The  length  of  time that a child is
       drawn is specified by <B>pfSeqTime</B>.  <I>frame</I> is the index of  a
       child  that  should be drawn for <I>time</I> seconds.  If <I>frame</I> &lt;
       0, then all children will be displayed for  <I>time</I>  seconds.
       If  <I>time</I>  =  0.0 or time is not specified for a particular
       child, then it will not be drawn at all.  If  <I>time</I>  &lt;  0.0
       the sequence will pause at child <I>frame</I> and draw it repeat-
       edly  until  the  sequence  is  resumed  or  stopped  (see
       <B>pfSeqMode</B> below).  <B>pfGetSeqTime</B> returns the time for frame
       <I>frame</I>.


       <I>mode</I> specifies how <I>seq</I> is sequenced over  the  range  from
       <I>begin</I> to <I>end</I> if it is a repeating sequence.

              <B>PFSEQ_CYCLE</B>
                   <I>seq</I>  will go from <I>begin</I> to <I>end</I> then restart at
                   <I>begin</I>.

              <B>PFSEQ_SWING</B>
                   <I>seq</I> will go back and forth from <I>begin</I> to  <I>end</I>.
                   The  endpoint  frames are drawn only once when
                   the swing changes directions.

       The default <I>mode</I> is <B>PFSEQ_CYCLE</B>.  <B>pfGetSeqInterval</B>  copies
       the interval parameters into <I>mode</I>, <I>begin</I>, and <I>end</I>.

       <B>pfSeqDuration</B> controls the duration of an sequence.  <I>speed</I>
       divides the time that each sequence  frame  is  displayed.
       Values  &lt;  1.0  slow  down the sequence while values &gt; 1.0
       speed up the sequence.  The default <I>speed</I> is  1.0.   <I>nReps</I>
       is  the  number  of times <I>seq</I> repeats before stopping.  If
       <I>nReps</I> is &lt; 0, <I>seq</I> will sequence indefinitely and if  ==  0
       the  sequence  is  disabled.   If  <I>nReps</I>  is &gt; 1, <I>seq</I> will
       sequence for <I>nReps</I>  cycles  or  swings  depending  on  the
       sequencing mode set by <B>pfSeqInterval</B>.

       The   number  of  repetitions  for  both  <B>PFSEQ_CYCLE</B>  and
       <B>PFSEQ_SWING</B> is increased by 1 every time  an  endpoint  of
       the  sequence is reached.  Therefore <B>PFSEQ_CYCLE</B> begins to
       repeat itself after 1 repetition while <B>PFSEQ_SWING</B> repeats
       itself  after  2 repetitions.  Note that for 1 repetition,
       both modes are equivalent.

       The default value for <I>nReps</I> is 1.  <B>pfGetSeqDuration</B> copies
       the duration parameters into <I>speed</I> and <I>nReps</I>.

       <B>pfSeqMode</B> controls the run-time execution of <I>seq</I>.  <I>mode</I> is
       a symbolic token:

              <B>PFSEQ_START</B>
                   Restarts  the  sequence  from  its  beginning.
                   Once  started,  a  sequence  may  be  stopped,
                   paused, or started again in which case  it  is
                   restarted from its beginning.

              <B>PFSEQ_STOP</B>
                   Stops  the  sequence.   After  an  sequence is
                   stopped, it is reset so  that  further  execu-
                   tions  of the sequence begin from the starting
                   index.

              <B>PFSEQ_PAUSE</B>
                   Pauses  the  sequence  without  resetting  it.
                   When  paused,  the current child will be drawn
                   until  the  sequence  is  either  stopped   or
                   resumed.

              <B>PFSEQ_RESUME</B>
                   Resumes a paused sequence.

       By default, all sequences belong  to  a  global  Performer
       list of sequences. All members of this list are considered
       for evaluation by <B>pfAppFrame</B>. Only  the  active  sequences
       are   actually  evaluated  but  looping  through  all  the
       sequences may be time consuming for scene graphs with many
       <B>pfSequence</B> nodes.  <B>pfSeqEvaluation</B> enables adding/removing
       a  pfSequence  to/from  the  global  Performer   list   of
       sequences.    <B>pfGetSeqEvaluation</B>   returns   TRUE  if  the
       sequence is in the global list.

       <B>pfGetSeqMode</B> returns the mode of <I>seq</I>.  The mode will auto-
       matically  be  set to <B>PFSEQ_STOP</B> if the sequence completes
       the number of repetitions set by <B>pfSeqDuration</B>.

       <B>pfGetSeqFrame</B> returns the index of the child which <I>seq</I>  is
       currently  drawing  and  also copies the number of repeti-
       tions it has completed into <I>repeat</I>.





</PRE>
<H2>SEE ALSO</H2><PRE>
       pfAppFrame, pfFrame,  pfFrameTimeStamp,  pfGroup,  pfNode,
       pfDelete



                                                  pfSequence(3pf)
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
