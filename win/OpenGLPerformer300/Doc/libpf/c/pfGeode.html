<HTML>
<HEAD>
<TITLE>pfGeode</TITLE>
</HEAD>
<BODY>
<H1>pfGeode</H1>
<HR>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->
pfGeode(3pf)                                         pfGeode(3pf)




</PRE>
<H2>NAME</H2><PRE>
       <B>pfNewGeode,</B>  <B>pfGetGeodeClassType,</B> <B>pfAddGSet,</B> <B>pfRemoveGSet,</B>
       <B>pfInsertGSet,</B> <B>pfReplaceGSet,</B>  <B>pfGetGSet,</B>  <B>pfGetNumGSets</B>  -
       Create, modify, and query a geometry node.


</PRE>
<H2>FUNCTION SPECIFICATION</H2><PRE>
       #include &lt;Performer/pf.h&gt;

       pfGeode *    <B>pfNewGeode</B>(void);

       pfType *     <B>pfGetGeodeClassType</B>(void);

       int          <B>pfAddGSet</B>(pfGeode* geode, pfGeoSet* gset);

       int          <B>pfRemoveGSet</B>(pfGeode* geode, pfGeoSet* gset);

       int          <B>pfInsertGSet</B>(pfGeode* geode,       int index,
                      pfGeoSet* gset);

       int          <B>pfReplaceGSet</B>(pfGeode* geode,  pfGeoSet* old,
                      pfGeoSet* new);

       pfGeoSet *   <B>pfGetGSet</B>(const pfGeode* geode, int index);

       int          <B>pfGetNumGSets</B>(const pfGeode* geode);


</PRE>
<H2>PARENT CLASS FUNCTIONS</H2><PRE>
       The OpenGL Performer class <B>pfGeode</B>  is  derived  from  the
       parent  class <B>pfNode</B>, so each of these member functions of
       class <B>pfNode</B> are also  directly  usable  with  objects  of
       class  <B>pfGeode</B>.   Casting an object of class <B>pfGeode</B> to an
       object of class <B>pfNode</B> is  taken  care  of  automatically.
       This is also true for casts to objects of ancestor classes
       of class <B>pfNode</B>.

       pfGroup *      <B>pfGetParent</B>(const pfNode *node, int i);
       int            <B>pfGetNumParents</B>(const pfNode *node);
       void           <B>pfNodeBSphere</B>(pfNode *node, pfSphere *bsph,
                        int mode);
       int            <B>pfGetNodeBSphere</B>(pfNode *node,
                        pfSphere *bsph);
       pfNode*        <B>pfClone</B>(pfNode *node, int mode);
       pfNode*        <B>pfBufferClone</B>(pfNode *node,       int mode,
                        pfBuffer *buf);
       int            <B>pfFlatten</B>(pfNode *node, int mode);
       int            <B>pfNodeName</B>(pfNode *node, const char *name);
       const char *   <B>pfGetNodeName</B>(const pfNode *node);
       pfNode*        <B>pfFindNode</B>(pfNode *node,  const char *path-
                        Name, pfType *type);
       pfNode*        <B>pfLookupNode</B>(const char *name,
                        pfType* type);
       int            <B>pfNodeIsectSegs</B>(pfNode *node,
                        pfSegSet *segSet, pfHit **hits[]);
       void           <B>pfNodeTravMask</B>(pfNode *node,     int which,
                        uint mask, int setMode, int bitOp);
                        pfNodeTravFuncType *post);
       void           <B>pfNodeTravData</B>(pfNode *node,     int which,
                        void *data);
       void *         <B>pfGetNodeTravData</B>(const pfNode *node,
                        int which);
       void           <B>pfNodeTravMode</B>(pfNode* node,     int which,
                        int mode, int val);
       int            <B>pfGetNodeTravMode</B>(const pfNode* node,
                        int which, int mode);


       Since  the  class <B>pfNode</B> is itself derived from the parent
       class <B>pfObject</B>, objects of class <B>pfGeode</B> can also be  used
       with   these  functions  designed  for  objects  of  class
       <B>pfObject</B>.

       void          <B>pfUserDataSlot</B>(pfObject *obj,      int slot,
                       void *data);
       void          <B>pfUserData</B>(pfObject *obj, void *data);
       void*         <B>pfGetUserDataSlot</B>(pfObject *obj, int slot);
       void*         <B>pfGetUserData</B>(pfObject *obj);
       int           <B>pfGetNumUserData</B>(pfObject *obj);
       int           <B>pfGetNamedUserDataSlot</B>(const char *name);
       const char*   <B>pfGetUserDataSlotName</B>(int slot);
       int           <B>pfGetNumNamedUserDataSlots</B>(void);
       int           <B>pfGetGLHandle</B>(pfObject *obj);
       int           <B>pfDeleteGLHandle</B>(pfObject *obj);


       Since the class <B>pfObject</B> is itself derived from the parent
       class <B>pfMemory</B>, objects of class <B>pfGeode</B> can also be  used
       with   these  functions  designed  for  objects  of  class
       <B>pfMemory</B>.

       pfType *       <B>pfGetType</B>(const void *ptr);
       int            <B>pfIsOfType</B>(const void *ptr, pfType *type);
       int            <B>pfIsExactType</B>(const void *ptr,
                        pfType *type);
       const char *   <B>pfGetTypeName</B>(const void *ptr);
       int            <B>pfRef</B>(void *ptr);
       int            <B>pfUnref</B>(void *ptr);
       int            <B>pfUnrefDelete</B>(void *ptr);
       int            <B>pfUnrefGetRef</B>(void *ptr);
       int            <B>pfGetRef</B>(const void *ptr);
       int            <B>pfCopy</B>(void *dst, void *src);
       int            <B>pfDelete</B>(void *ptr);
       int            <B>pfIsFluxed</B>(void *ptr);
       int            <B>pfCompare</B>(const void *ptr1,
                        const void *ptr2);
       void           <B>pfPrint</B>(const void *ptr,        uint which,
                        uint verbose, FILE *file);
       void *         <B>pfGetArena</B>(void *ptr);


</PRE>
<H2>PARAMETERS</H2><PRE>
       <I>geode</I>  identifies a pfGeode.


</PRE>
<H2>DESCRIPTION</H2><PRE>
       The  name "pfGeode" is short for Geometry Node.  A pfGeode
       is a leaf node in the OpenGL Performer scene graph hierar-
       The bounding volume of a pfGeode is that  which  surrounds
       all  its pfGeoSets.  Unless the bounding volume is consid-
       ered static (see  <B>pfNodeBSphere</B>),  OpenGL  Performer  will
       compute  a  new volume when the list of pfGeoSets is modi-
       fied   by   <B>pfAddGSet</B>,   <B>pfRemoveGSet</B>,   <B>pfInsertGSet</B>   or
       <B>pfReplaceGSet</B>.   If  the  bounding box of a child pfGeoSet
       changes, call <B>pfNodeBSphere</B> to tell  OpenGL  Performer  to
       update the bounding volume of the pfGeode.

       <B>pfNewGeode</B>  creates  and  returns  a  handle to a pfGeode.
       Like other pfNodes, pfGeodes  are  always  allocated  from
       shared memory and can be deleted using <B>pfDelete</B>.

       <B>pfGetGeodeClassType</B>  returns  the  <B>pfType</B>*  for  the class
       <B>pfGeode</B>.  The <B>pfType</B>* returned by  <B>pfGetGeodeClassType</B>  is
       the  same as the <B>pfType</B>* returned by invoking <B>pfGetType</B> on
       any instance of class <B>pfGeode</B>.  Because  OpenGL  Performer
       allows  subclassing  of built-in types, when decisions are
       made based on the type of an object, it is usually  better
       to  use  <B>pfIsOfType</B>  to  test  if  an  object is of a type
       derived from a Performer type  rather  than  to  test  for
       strict equality of the <B>pfType</B>*'s.


       <B>pfAddGSet</B>   appends   <I>gset</I>   to   <I>geode</I>'s  pfGeoSet  list.
       <B>pfRemoveGSet</B> removes <I>gset</I> from the  list  and  shifts  the
       list  down over the vacant spot.  For example, if <I>gset</I> had
       index 0, then index 1 becomes index  0,  index  2  becomes
       index  1  and so on.  <B>pfRemoveGSet</B> returns a 1 if <I>gset</I> was
       actually removed and 0 if it was not found  in  the  list.
       <B>pfAddGSet</B>  and <B>pfRemoveGSet</B> will cause OpenGL Performer to
       recompute new bounding volumes for <I>geode</I> unless it is con-
       figured to use static bounding volumes.

       <B>pfInsertGSet</B>  will  insert  <I>gset</I>  before the pfGeoSet with
       index  <I>index</I>.   <I>index</I>  must  be  within  the  range  0  to
       <B>pfGetNumGSets</B>(<I>geode</I>).  <B>pfReplaceGSet</B> replaces <I>old</I> with <I>new</I>
       and returns 1 if the operation was successful or 0 if  <I>old</I>
       was not found in the list.  <B>pfInsertGSet</B> and <B>pfReplaceGSet</B>
       will cause OpenGL Performer to recompute new bounding vol-
       umes  for  <I>geode</I>  unless  it  is  configured to use static
       bounding volumes.

       <B>pfGetNumGSets</B> returns the number of  pfGeoSets  in  <I>geode</I>.
       <B>pfGetGSet</B>  returns  a  handle  to  the pfGeoSet with index
       <I>index</I> or <B>NULL</B> if the index is out of range.

       If  database  sorting  is  disabled,  that   is   if   the
       <B>PFCULL_SORT</B>   mode  of  <B>pfChanTravMode</B>  is  not  set,  the
       pfGeoSets in a pfGeode will be drawn  in  the  order  they
       appear  on  the  list.  If sorting is enabled, there is no
       guarantee about the drawing order, since the reordering of
       GeoSets  for minimum state-changing overhead is one of the
       primary design motivations of OpenGL Performer's libpf and
       libpr.


</PRE>
<H2>NOTES</H2><PRE>
       pfGeode  geometry is not multibuffered by OpenGL Performer
       when in multiprocessing mode  in  order  to  save  memory.
       and deletion of vertices are not  currently  supported  by
       OpenGL Performer.  However, the application may handle its
       own multibuffering of pfGeodes  through  mutual  exclusion
       with  locks or through the use of parallel data structures
       and pfSwitch nodes to achieve any kind of  dynamic  geome-
       try.

       The  shifting behavior of <B>pfRemoveGSet</B> can cause some con-
       fusion.  The following sample code shows how to remove all
       pfGeoSets from <I>geode</I>:


       int  i;
       int  n = pfGetNumGSets(geode);

       for (i = 0; i &lt; n; i++)
           pfRemoveGSet(geode, pfGetGSet(geode, 0)); /* 0, not i */

       Alternately, you can traverse the list from back to front,
       in which case the shift never hits the fan.

       int  i;
       int  n = pfGetNumGSets(geode);

       for (i = n - 1; i &gt;= 0; i--)
           pfRemoveGSet(geode, pfGetGSet(geode, i)); /* i, not 0 */


       When sorting is enabled (see <B>pfChanTravMode</B> and
       <B>PFCULL_SORT</B>), transparent pfGeoSets are drawn last unless
       the pfGeode has a pre or post draw callback (see
       <B>pfNodeTravFuncs</B>).  Drawing transparent pfGeoSets after
       opaque geometry reduces artifacts when blended trans-
       parency (see <B>pfTransparency</B>) is used and can improve fill
       rate performance.


</PRE>
<H2>SEE ALSO</H2><PRE>
       pfChanTravMode, pfGeoSet, pfNode, pfNodeTravFuncs,
       pfTransparency, pfDelete



                                                     pfGeode(3pf)
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
