<HTML>
<HEAD>
<TITLE>pfDoubleDCS</TITLE>
</HEAD>
<BODY>
<H1>pfDoubleDCS</H1>
<HR>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->
pfDoubleDCS(3pf)                                 pfDoubleDCS(3pf)




</PRE>
<H2>NAME</H2><PRE>
       <B>pfNewDoubleDCS,</B> <B>pfGetDoubleDCSClassType,</B> <B>pfDoubleDCSTrans,</B>
       <B>pfDoubleDCSRot,</B> <B>pfDoubleDCSCoord,</B> <B>pfDoubleDCSScale,</B> <B>pfDou-</B>
       <B>bleDCSScaleXYZ,</B>  <B>pfDoubleDCSMat,</B> <B>pfGetDoubleDCSMat,</B> <B>pfGet-</B>
       <B>DoubleDCSMatPtr,</B> <B>pfDoubleDCSMatType,</B> <B>pfGetDoubleDCSMatType</B>
       -  Create, modify and get the matrix of a double-precision
       dynamic coordinate system.


</PRE>
<H2>FUNCTION SPECIFICATION</H2><PRE>
       #include &lt;Performer/pf.h&gt;

       pfDoubleDCS *       <B>pfNewDoubleDCS</B>(void);

       pfType *            <B>pfGetDoubleDCSClassType</B>(void);

       void                <B>pfDoubleDCSTrans</B>(pfDoubleDCS *dcs,
                             double x, double y, double z);

       void                <B>pfDoubleDCSRot</B>(pfDoubleDCS *dcs,  dou-
                             ble h, double p, double r);

       void                <B>pfDoubleDCSCoord</B>(pfDoubleDCS *dcs,
                             pfCoordd *coord);

       void                <B>pfDoubleDCSScale</B>(pfDoubleDCS *dcs,
                             double s);

       void                <B>pfDoubleDCSScaleXYZ</B>(pfDoubleDCS *dcs,
                             double x, double y, double z);

       void                <B>pfDoubleDCSMat</B>(pfDoubleDCS *dcs, pfMa-
                             trix4d m);

       void                <B>pfGetDoubleDCSMat</B>(pfDoubleDCS *dcs,
                             pfMatrix4d m);

       const
                           pfMatrix4d*   <B>pfGetDoubleDCSMatPtr</B>(pfDoubleDCS *dcs);

       void                <B>pfDoubleDCSMatType</B>(pfDoubleDCS *dcs,
                             uint val);

       uint                <B>pfGetDoubleDCSMatType</B>(pfDoubleDCS *dcs);


</PRE>
<H2>PARENT CLASS FUNCTIONS</H2><PRE>
       The OpenGL Performer class <B>pfDoubleDCS</B> is derived from the
       parent class <B>pfDoubleSCS</B>, so each of  these  member  func-
       tions  of  class <B>pfDoubleSCS</B> are also directly usable with
       objects of class <B>pfDoubleDCS</B>.  Casting an object of  class
       <B>pfDoubleDCS</B>  to  an  object  of class <B>pfDoubleSCS</B> is taken
       care of automatically.  This is also  true  for  casts  to
       objects of ancestor classes of class <B>pfDoubleSCS</B>.

       void                <B>pfGetDoubleSCSMat</B>(pfDoubleSCS *scs,
                             pfMatrix4d mat);

       class <B>pfGroup</B>.

       int        <B>pfAddChild</B>(pfGroup *group, pfNode *child);
       int        <B>pfInsertChild</B>(pfGroup *group,  int index,  pfN-
                    ode *child);
       int        <B>pfReplaceChild</B>(pfGroup *group,     pfNode *old,
                    pfNode *new);
       int        <B>pfRemoveChild</B>(pfGroup *group, pfNode* child);
       int        <B>pfSearchChild</B>(pfGroup *group, pfNode* child);
       pfNode *   <B>pfGetChild</B>(const pfGroup *group, int index);
       int        <B>pfGetNumChildren</B>(const pfGroup *group);
       int        <B>pfBufferAddChild</B>(pfGroup *group,           pfN-
                    ode *child);
       int        <B>pfBufferRemoveChild</B>(pfGroup *group,        pfN-
                    ode *child);


       Since  the class <B>pfGroup</B> is itself derived from the parent
       class <B>pfNode</B>, objects of class  <B>pfDoubleDCS</B>  can  also  be
       used  with  these  functions designed for objects of class
       <B>pfNode</B>.

       pfGroup *      <B>pfGetParent</B>(const pfNode *node, int i);
       int            <B>pfGetNumParents</B>(const pfNode *node);
       void           <B>pfNodeBSphere</B>(pfNode *node, pfSphere *bsph,
                        int mode);
       int            <B>pfGetNodeBSphere</B>(pfNode *node,
                        pfSphere *bsph);
       pfNode*        <B>pfClone</B>(pfNode *node, int mode);
       pfNode*        <B>pfBufferClone</B>(pfNode *node,       int mode,
                        pfBuffer *buf);
       int            <B>pfFlatten</B>(pfNode *node, int mode);
       int            <B>pfNodeName</B>(pfNode *node, const char *name);
       const char *   <B>pfGetNodeName</B>(const pfNode *node);
       pfNode*        <B>pfFindNode</B>(pfNode *node,  const char *path-
                        Name, pfType *type);
       pfNode*        <B>pfLookupNode</B>(const char *name,
                        pfType* type);
       int            <B>pfNodeIsectSegs</B>(pfNode *node,
                        pfSegSet *segSet, pfHit **hits[]);
       void           <B>pfNodeTravMask</B>(pfNode *node,     int which,
                        uint mask, int setMode, int bitOp);
       uint           <B>pfGetNodeTravMask</B>(const pfNode *node,
                        int which);
       void           <B>pfNodeTravFuncs</B>(pfNode* node,    int which,
                        pfNodeTravFuncType pre, pfNodeTravFunc-
                        Type post);
       void           <B>pfGetNodeTravFuncs</B>(const pfNode* node,
                        int which,     pfNodeTravFuncType *pre,
                        pfNodeTravFuncType *post);
       void           <B>pfNodeTravData</B>(pfNode *node,     int which,
                        void *data);
       void *         <B>pfGetNodeTravData</B>(const pfNode *node,
                        int which);
       void           <B>pfNodeTravMode</B>(pfNode* node,     int which,
                        int mode, int val);
       int            <B>pfGetNodeTravMode</B>(const pfNode* node,
                        int which, int mode);

                       void *data);
       void          <B>pfUserData</B>(pfObject *obj, void *data);
       void*         <B>pfGetUserDataSlot</B>(pfObject *obj, int slot);
       void*         <B>pfGetUserData</B>(pfObject *obj);
       int           <B>pfGetNumUserData</B>(pfObject *obj);
       int           <B>pfGetNamedUserDataSlot</B>(const char *name);
       const char*   <B>pfGetUserDataSlotName</B>(int slot);
       int           <B>pfGetNumNamedUserDataSlots</B>(void);
       int           <B>pfGetGLHandle</B>(pfObject *obj);
       int           <B>pfDeleteGLHandle</B>(pfObject *obj);


       Since the class <B>pfObject</B> is itself derived from the parent
       class <B>pfMemory</B>, objects of class <B>pfDoubleDCS</B> can  also  be
       used  with  these  functions designed for objects of class
       <B>pfMemory</B>.

       pfType *       <B>pfGetType</B>(const void *ptr);
       int            <B>pfIsOfType</B>(const void *ptr, pfType *type);
       int            <B>pfIsExactType</B>(const void *ptr,
                        pfType *type);
       const char *   <B>pfGetTypeName</B>(const void *ptr);
       int            <B>pfRef</B>(void *ptr);
       int            <B>pfUnref</B>(void *ptr);
       int            <B>pfUnrefDelete</B>(void *ptr);
       int            <B>pfUnrefGetRef</B>(void *ptr);
       int            <B>pfGetRef</B>(const void *ptr);
       int            <B>pfCopy</B>(void *dst, void *src);
       int            <B>pfDelete</B>(void *ptr);
       int            <B>pfIsFluxed</B>(void *ptr);
       int            <B>pfCompare</B>(const void *ptr1,
                        const void *ptr2);
       void           <B>pfPrint</B>(const void *ptr,        uint which,
                        uint verbose, FILE *file);
       void *         <B>pfGetArena</B>(void *ptr);


</PRE>
<H2>PARAMETERS</H2><PRE>
       <I>dcs</I>  identifies a pfDoubleDCS


</PRE>
<H2>DESCRIPTION</H2><PRE>
       A pfDoubleDCS (Double-precision Dynamic Coordinate System)
       is a pfDoubleSCS whose matrix can be modified. It is  use-
       ful  for generating scenes with objects very far away from
       the origin.

       <B>pfNewDoubleDCS</B> creates and returns a handle  to  a  pfDou-
       bleDCS.   Like  other  pfNodes,  pfDoubleDCSes  are always
       allocated from shared memory  and  can  be  deleted  using
       <B>pfDelete</B>.

       <B>pfGetDoubleDCSClassType</B>  returns the <B>pfType</B>* for the class
       <B>pfDoubleDCS</B>.       The      <B>pfType</B>*      returned       by
       <B>pfGetDoubleDCSClassType</B>   is   the  same  as  the  <B>pfType</B>*
       returned by invoking <B>pfGetType</B> on any  instance  of  class
       <B>pfDoubleDCS</B>.   Because OpenGL Performer allows subclassing
       of built-in types, when decisions are made  based  on  the
       type  of an object, it is usually better to use <B>pfIsOfType</B>
       to test if an object is of a type derived from a Performer
       type  rather  than  to  test  for  strict  equality of the
       scale,  R  is  the rotation, and T is the translation. The
       order of effect is then scale followed  by  rotation  fol-
       lowed by translation.

       pfDoubleDCS  operations  are  absolute rather than cumula-
       tive.  For example:

       pfDoubleDCSTrans(dcs, 2.0f, 0.0f, 0.0f);
       pfDoubleDCSTrans(dcs, 1.0f, 0.0f, 0.0f);

       specifies a translation by 1 unit along the X coordinate
       axis, not 3 units.

       By default a pfDoubleDCS uses a bounding sphere which is
       dynamic, so it is automatically updated when the pfDou-
       bleDCS transformation is changed or when children are
       added, deleted or changed.  This behavior may be changed
       using <B>pfNodeBSphere</B>.  The bound for a pfDoubleDCS encom-
       passes all B(i)*S*R*T, where B(i) is the bound for the
       child 'i' and S*R*T represents the scale, rotation, and
       translation transformation of the pfDoubleDCS.

       <B>pfDoubleDCSTrans</B> sets the translation part of the pfDou-
       bleDCS to (<I>x</I>, <I>y</I>, <I>z</I>).  The rotational portion of the matrix
       is unchanged.

       <B>pfDoubleDCSScale</B> sets the scale portion of the pfDoubleDCS
       to scale uniformly by a scale factor <I>s</I>.  This supersedes
       the previous scale leaving the rotation and translation
       unchanged. <B>pfDoubleDCSScaleXYZ</B> specifies a non-uniform
       scale of <I>x</I>, <I>y</I>, <I>z</I>.

       <B>pfDoubleDCSRot</B> sets the rotation portion of the matrix:

              <I>h</I>    Specifies heading, the rotation about the Z
                   axis.

              <I>p</I>    Specifies pitch, the rotation about the X
                   axis.

              <I>r</I>    Specifies roll, rotation about the Y axis.

       The matrix created is R*P*H, where R is the roll trans-
       form, P is the pitch transform and H is the heading trans-
       form.  The new (h,p,r) combination replaces the previous
       specification, leaving the scale and translation
       unchanged.  The convention is natural for a model in which
       +Y is "forward," +Z is "up" and +X is "right".  To main-
       tain 1/1000 degree resolution in the single precision
       arithmetic used internally for sine and cosine calcula-
       tions, the angles <I>h</I>, <I>p</I>, <I>r</I> should be in the range of -7500
       to +7500 degrees.

       <B>pfDoubleDCSCoord</B> sets the rotation and translation portion
       of the pfDoubleDCS according to <I>coord</I>.  This is equivalent
       to:

       pfDoubleDCSRot(<I>dcs</I>, coord-&gt;hpr[0], coord-&gt;hpr[1], coord-&gt;hpr[2]);
       pfDoubleDCSTrans(<I>dcs</I>, coord-&gt;xyz[0], coord-&gt;xyz[1], coord-&gt;xyz[2]);
       and translational components.  The mechanisms can be com-
       bined but only if the supplied matrix can be represented
       as scale followed by a rotation followed by a translation
       (e.g. a point pt is transformed by the matrix as: pt' =
       pt*S*R*T), which implies that no shearing or non-uniform
       scaling is present.

       <B>pfDoubleDCSMatType</B> allows the specification of information
       about the type of transformation the matrix represents.
       This information allows Performer to speed up some opera-
       tions.  The matrix type is specified as the OR of

              PFMAT_TRANS: matrix may include a translational
              component in the 4th row.

              PFMAT_ROT
                     matrix may include a rotational component in
                     the left upper 3X3 submatrix.

              PFMAT_SCALE
                     matrix may include a uniform scale in the
                     left upper 3X3 submatrix.

              PFMAT_NONORTHO
                     matrix may include a non-uniform scale in
                     the left upper 3X3 submatrix.

              PFMAT_PROJ
                     matrix may include projections.

              PFMAT_HOM_SCALE
                     matrix may have mat[4][4] != 1.

              PFMAT_MIRROR
                     matrix may include mirroring transformation
                     that switches between right handed and left
                     handed coordinate systems.

       <B>pfGetDoubleDCSMatType</B> returns the matrix type as set by
       <B>pfDoubleDCSMatType</B>.  If no matrix type is set the default
       is ~0, corresponding to a general matrix.

       The transformation of a pfDoubleDCS affects all its chil-
       dren.  As the hierarchy is traversed from top to bottom,
       each new matrix is pre-multiplied to create the new trans-
       formation.  For example, if DoubleDCSb is below DoubleDCSa
       in the scene graph, any geometry G below DoubleDCSa is
       transformed as G*DoubleDCSb*DoubleDCSa.

       <B>pfFlatten</B> cannot flatten pfDoubleDCSes since they may
       change at run-time.  In this case <B>pfFlatten</B> will compute a
       pfDoubleSCS representing the accumulated static transfor-
       mation that the pfDoubleDCS inherits and insert it above
       the pfDoubleDCS.  Static transformations below a pfDou-
       bleDCS are flattened as usual.  See <B>pfFlatten</B> for more
       details.

       The presence of transformations in the scene graph impacts
       the performance of intersection, culling and drawing.
       pfDoubleDCS matrix will already have been applied to the
       matrix stack before the pre callback is called and will be
       popped only after the post callback is called.

       <B>pfGetDoubleDCSMat</B> copies the transformation matrix value
       from <I>dcs</I> into the matrix <I>m</I>.  For faster matrix access,
       <B>pfGetDoubleDCSMatPtr</B> can be used to get a const pointer to
       <I>dcs</I>'s matrix.

       <B>pfDoubleDCS</B> nodes are useful for modeling objects very far
       from the origin or the database - so far away that the
       resolution of floating point numbers isn't high enough to
       express small movements of the objects. We use a common
       example to describe this feature of <B>pfDoubleDCS</B> nodes:

       When modeling a round Earth and placing the origin in the
       center of the Earth, the surface of the Earth is very far
       from the origin. The resolution of floating point numbers
       is not high enough to express translations of 1 cm on the
       surface of the Earth.

       Since the underlying OpenGL implementation does not sup-
       port double-precision math, modeling in double precision
       numbers does not help. Instead, we observe that when we
       fly/drive over the surface of the Earth, we want to depict
       small translations only in the vicinity of the camera.
       Translating an object 200 miles away from the camera by 1
       cm has negligible effect on the output image.  <B>pfDoubleDCS</B>
       nodes provide a method to translate the camera position to
       the origin of the database every frame, and to correct the
       relative position of the scene to that of the camera. This
       way, all the geometry in the vicinity of the camera
       becomes close enough to the origin that the resolution of
       floating point numbers is high enough to express small
       object translations.

       In more practical terms, given a camera position at <I>E</I> <I>=</I>
       <I>(Ex,</I> <I>Ey,</I> <I>Ez)</I>, and a database tile position at <I>T</I> <I>=</I> <I>(Tx,</I> <I>Ty,</I>
       <I>Tz)</I>, we build a scene graph with a single <B>pfDoubleDCS</B> node
       at the root, and one <B>pfDoubleDCS</B> node above each tile. We
       set the channel eyepoint in the origin by seting the chan-
       nel viewing matrix to the identity matrix. We then use the
       <B>pfDoubleDCS</B> node at the root to express the real camera
       position and the <B>pfDoubleDCS</B> node above each tile to
       express the position of the tile.  We load the translation
       <I>-E</I> <I>=</I> <I>(-Ex,</I> <I>-Ey,</I> <I>-Ez)</I> onto the root <B>pfDoubleDCS</B> and the
       translation <I>T</I> <I>=</I> <I>(Tx,</I> <I>Ty,</I> <I>Tz)</I> onto the tile <B>pfDoubleDCS</B>.
       When Performer traverses the scene graph, it composes the
       final translation <I>T-E</I> <I>=</I> <I>(Tx-Ex,</I> <I>Ty-Ey,</I> <I>Tz-Ez)</I>. When the
       camera is fairly close to the tile, this translation is
       small enough that even floating point numbers provide a
       high enough resolution for it.

       Coding the above example we get:


       void
       setDoublePrecisionDCS (pfChannel *chan,
                              pfDoubleDCS *ddcs,

           pfMakeCoorddMat4d (mat, coord);

           pfInvertOrthoNMat4d (invMat, mat);

           /* Put inverse of camera position in double DCS. */
           pfDoubleDCSMat (ddcs, invMat);
       }


       where <I>coord</I> contains the camera position, and <I>ddcs</I> is the
       <B>pfDoubleDCS</B> at the root of the scene graph. Every time the
       camera position changes, we have to update the <B>pfDoubleDCS</B>
       at the root of the scene graph.  The tiles contain vertex
       coordinates relative to the tile origin. This origin is
       translated by the tile <B>pfDoubleDCS</B> to the correct posi-
       tion.

       <B>Important</B> <B>Note</B>

       During the Performer CULL traversal, Performer maintains
       the accumulated matrix from the root of the scene graph to
       the current node. Performer also maintains the precision
       level of this accumulated matrix. When the last matrix
       node on the path from the root of the scene graph to a
       node is a double-precision matrix, the CULL test is
       ignored on this node. In other words, all the nodes whose
       closest parent matrix node is a double-precision node are
       accepted by the CULL traversal and are always drawn.

       Performer does not CULL these nodes because the standard
       Performer node bounding sphere is single-precision and can
       not correctly express double precision matrix operations.
       Converting to double-precision bounding spheres would have
       slowed down the CULL traversal.

       There is a simple workaround that forces Performer back to
       single precision mode: Add a <B>pfSCS</B> node below the lowest
       <B>pfDouble?CS</B> node. Use an identity matrix for the new <B>pfSCS</B>
       node. The <B>pfSCS</B> node demotes the CULL traversal back to
       single-precision mode, and the CULL test becomes active
       again.

       The sample code under /usr/share/Per-
       former/src/pguide/libpf/C/doubleDCS2.c demonstrates how to
       create a scene graph with the correct node setup.



</PRE>
<H2>SEE ALSO</H2><PRE>
       pfCoord, pfGroup, pfChanTravMode, pfLookupNode, pfFlatten,
       pfMatrix, pfNode, pfDCS, pfSCS, pfFCS, pfDoubleSCS, pfDou-
       bleFCS, pfScene, pfTraverser, pfDelete



                                                 pfDoubleDCS(3pf)
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
