<HTML>
<HEAD>
<TITLE>pfMorph</TITLE>
</HEAD>
<BODY>
<H1>pfMorph</H1>
<HR>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->

</PRE>
<H2>pfMorph OBSOLETED bypfMorphnOBSOLETEDlby(pfEngine and pfFlux(3pf)</H2><PRE>




</PRE>
<H2>NAME</H2><PRE>
       <B>pfNewMorph,</B>   <B>pfGetMorphClassType,</B>   <B>pfMorphAttr,</B>   <B>pfMor-</B>
       <B>phWeights,</B> <B>pfGetMorphWeights,</B>  <B>pfGetMorphNumAttrs,</B>  <B>pfGet-</B>
       <B>MorphSrc,</B>  <B>pfGetMorphNumSrcs,</B>  <B>pfGetMorphDst,</B>  <B>pfEvaluate-</B>
       <B>Morph</B> - Create, modify, and query a pfMorph node.


</PRE>
<H2>FUNCTION SPECIFICATION</H2><PRE>
       #include &lt;Performer/pf.h&gt;

       pfMorph *   <B>pfNewMorph</B>(void);

       pfType *    <B>pfGetMorphClassType</B>(void);

       int         <B>pfMorphAttr</B>(pfMorph *morph,         int index,
                     int floatsPerElt,   int nelts,  void *dst,
                     int nsrcs,                 float *alist[],
                     ushort *ilist[], int nlist[]);

       int         <B>pfMorphWeights</B>(pfMorph *morph,      int index,
                     float *weights);

       int         <B>pfGetMorphWeights</B>(const pfMorph *morph,
                     int index, float *weights);

       int         <B>pfGetMorphNumAttrs</B>(const pfMorph *morph);

       int         <B>pfGetMorphSrc</B>(const pfMorph *morph, int index,
                     int src,  float **alist,   ushort **ilist,
                     int *nlist);

       int         <B>pfGetMorphNumSrcs</B>(const pfMorph *morph,
                     int index);

       void *      <B>pfGetMorphDst</B>(const pfMorph *morph,
                     int index);

       void        <B>pfEvaluateMorph</B>(pfMorph *morph);


</PRE>
<H2>PARENT CLASS FUNCTIONS</H2><PRE>
       The  OpenGL  Performer  class  <B>pfMorph</B> is derived from the
       parent class <B>pfGroup</B>, so each of these member functions of
       class  <B>pfGroup</B>  are  also  directly usable with objects of
       class <B>pfMorph</B>.  Casting an object of class <B>pfMorph</B>  to  an
       object  of  class  <B>pfGroup</B> is taken care of automatically.
       This is also true for casts to objects of ancestor classes
       of class <B>pfGroup</B>.

       int        <B>pfAddChild</B>(pfGroup *group, pfNode *child);
       int        <B>pfInsertChild</B>(pfGroup *group,  int index,  pfN-
                    ode *child);
       int        <B>pfReplaceChild</B>(pfGroup *group,     pfNode *old,
                    pfNode *new);
       int        <B>pfRemoveChild</B>(pfGroup *group, pfNode* child);
       int        <B>pfSearchChild</B>(pfGroup *group, pfNode* child);
       pfNode *   <B>pfGetChild</B>(const pfGroup *group, int index);
       Since  the class <B>pfGroup</B> is itself derived from the parent
       class <B>pfNode</B>, objects of class <B>pfMorph</B> can  also  be  used
       with these functions designed for objects of class <B>pfNode</B>.

       pfGroup *      <B>pfGetParent</B>(const pfNode *node, int i);
       int            <B>pfGetNumParents</B>(const pfNode *node);
       void           <B>pfNodeBSphere</B>(pfNode *node, pfSphere *bsph,
                        int mode);
       int            <B>pfGetNodeBSphere</B>(pfNode *node,
                        pfSphere *bsph);
       pfNode*        <B>pfClone</B>(pfNode *node, int mode);
       pfNode*        <B>pfBufferClone</B>(pfNode *node,       int mode,
                        pfBuffer *buf);
       int            <B>pfFlatten</B>(pfNode *node, int mode);
       int            <B>pfNodeName</B>(pfNode *node, const char *name);
       const char *   <B>pfGetNodeName</B>(const pfNode *node);
       pfNode*        <B>pfFindNode</B>(pfNode *node,  const char *path-
                        Name, pfType *type);
       pfNode*        <B>pfLookupNode</B>(const char *name,
                        pfType* type);
       int            <B>pfNodeIsectSegs</B>(pfNode *node,
                        pfSegSet *segSet, pfHit **hits[]);
       void           <B>pfNodeTravMask</B>(pfNode *node,     int which,
                        uint mask, int setMode, int bitOp);
       uint           <B>pfGetNodeTravMask</B>(const pfNode *node,
                        int which);
       void           <B>pfNodeTravFuncs</B>(pfNode* node,    int which,
                        pfNodeTravFuncType pre, pfNodeTravFunc-
                        Type post);
       void           <B>pfGetNodeTravFuncs</B>(const pfNode* node,
                        int which,     pfNodeTravFuncType *pre,
                        pfNodeTravFuncType *post);
       void           <B>pfNodeTravData</B>(pfNode *node,     int which,
                        void *data);
       void *         <B>pfGetNodeTravData</B>(const pfNode *node,
                        int which);
       void           <B>pfNodeTravMode</B>(pfNode* node,     int which,
                        int mode, int val);
       int            <B>pfGetNodeTravMode</B>(const pfNode* node,
                        int which, int mode);


       Since  the  class <B>pfNode</B> is itself derived from the parent
       class <B>pfObject</B>, objects of class <B>pfMorph</B> can also be  used
       with   these  functions  designed  for  objects  of  class
       <B>pfObject</B>.

       void          <B>pfUserDataSlot</B>(pfObject *obj,      int slot,
                       void *data);
       void          <B>pfUserData</B>(pfObject *obj, void *data);
       void*         <B>pfGetUserDataSlot</B>(pfObject *obj, int slot);
       void*         <B>pfGetUserData</B>(pfObject *obj);
       int           <B>pfGetNumUserData</B>(pfObject *obj);
       int           <B>pfGetNamedUserDataSlot</B>(const char *name);
       const char*   <B>pfGetUserDataSlotName</B>(int slot);
       int           <B>pfGetNumNamedUserDataSlots</B>(void);
       int           <B>pfGetGLHandle</B>(pfObject *obj);
       int           <B>pfDeleteGLHandle</B>(pfObject *obj);

       int            <B>pfIsOfType</B>(const void *ptr, pfType *type);
       int            <B>pfIsExactType</B>(const void *ptr,
                        pfType *type);
       const char *   <B>pfGetTypeName</B>(const void *ptr);
       int            <B>pfRef</B>(void *ptr);
       int            <B>pfUnref</B>(void *ptr);
       int            <B>pfUnrefDelete</B>(void *ptr);
       int            <B>pfUnrefGetRef</B>(void *ptr);
       int            <B>pfGetRef</B>(const void *ptr);
       int            <B>pfCopy</B>(void *dst, void *src);
       int            <B>pfDelete</B>(void *ptr);
       int            <B>pfIsFluxed</B>(void *ptr);
       int            <B>pfCompare</B>(const void *ptr1,
                        const void *ptr2);
       void           <B>pfPrint</B>(const void *ptr,        uint which,
                        uint verbose, FILE *file);
       void *         <B>pfGetArena</B>(void *ptr);


</PRE>
<H2>PARAMETERS</H2><PRE>
       <I>morph</I>  identifies a pfMorph.


</PRE>
<H2>DESCRIPTION</H2><PRE>
       A pfMorph node does not define geometry; rather, it manip-
       ulates geometric attributes of pfGeoSets and other geomet-
       ric  primitives.   While pfMorph is very general, its pri-
       mary use is for geometric morphing where the colors,  nor-
       mals,  texture coordinates and coordinates of geometry are
       smoothly changed over time to  simulate  actions  such  as
       facial  and  skeletal  animation,  ocean waves, continuous
       level-of-detail, and advanced special  effects.  In  these
       situations,  the  rigid  body  transformations provided by
       matrices do not suffice -  instead,  efficient  per-vertex
       manipulations are required.

       A  pfMorph  consists of one or more "sources" and a single
       "destination" which together are  termed  an  "attribute".
       Both  sources  and  destination  are  arrays of "elements"
       where each element consists of 1 or  more  floating  point
       numbers,  e.g.,  an  array  of  pfVec3  coordinates.   The
       pfMorph node  produces  the  destination  by  computing  a
       weighted sum of the sources. By varying the source weights
       and using the morph destination as  a  pfGeoSet  attribute
       array,  the application can achieve smooth, geometric ani-
       mation. A pfMorph can "morph" multiple attributes.

       <B>pfNewMorph</B> creates and returns  a  handle  to  a  pfMorph.
       Like  other  pfNodes,  pfMorphs  are always allocated from
       shared memory and can be deleted using <B>pfDelete</B>.

       <B>pfGetMorphClassType</B> returns  the  <B>pfType</B>*  for  the  class
       <B>pfMorph</B>.   The  <B>pfType</B>* returned by <B>pfGetMorphClassType</B> is
       the same as the <B>pfType</B>* returned by invoking <B>pfGetType</B>  on
       any  instance  of class <B>pfMorph</B>.  Because OpenGL Performer
       allows subclassing of built-in types, when  decisions  are
       made  based on the type of an object, it is usually better
       to use <B>pfIsOfType</B> to test  if  an  object  is  of  a  type
       derived  from  a  Performer  type  rather than to test for
       strict equality of the <B>pfType</B>*'s.

       number  of pfGeoSet coordinates is 33, then <I>nelts</I> would be
       33, <I>not</I> 33 * 3 = 99. <I>dst</I> is a pointer to  the  destination
       array  which  should  be  at  least of size <I>floatsPerElt</I> *
       <I>nelts</I> * sizeof(float). If <I>dst</I> is  <B>NULL</B>,  then  <I>morph</I>  will
       automatically  create and use a pfCycleBuffer of appropri-
       ate size.  (pfCycleBuffers are  useful  when  OpenGL  Per-
       former is configured to multiprocess.)

       There  are  2  distinct  methods  of  accessing the source
       arrays of a pfMorph attribute:  non-indexed  and  indexed.
       Indexing  provides  a means of efficiently applying sparse
       changes to the destination array.  The <I>nsrcs</I>  argument  to
       <B>pfMorphAttr</B>  specifies how many source arrays are provided
       in <I>alist</I>, i.e., <I>alist</I>[i] is the i'th source and is treated
       as  an  array  of  elements where each element consists of
       <I>floatsPerElt</I> floating  point  numbers.  Index  arrays  and
       their  lengths  are  provided  in  <I>ilist</I> and <I>nlist</I> respec-
       tively. If <I>ilist</I> is <B>NULL</B> then all sources are non-indexed.
       If  <I>ilist</I>  is  non-<B>NULL</B>, it contains a list of index lists
       corresponding to the source lists in <I>alist</I>.  If  <I>nlist</I>  is
       <B>NULL</B>,  then  the  index lists are assumed to be <I>nelts</I> long
       and if non-<B>NULL</B>, the length of each index list  is  speci-
       fied  in  <I>nlist</I>.  <I>ilist</I>  may  contain <B>NULL</B> pointers to mix
       indexed and non-indexed source arrays.

       All source arrays referenced in <I>alist</I> and <I>ilist</I> are refer-
       ence counted by <B>pfMorphAttr</B>.

       <B>pfMorphWeights</B> specifies the source weights of the <I>index</I>th
       attribute of <I>morph</I> in the array  <I>weights</I>.  <I>weights</I>  should
       consist of <I>nsrcs</I> floating point numbers where <I>nsrcs</I> is the
       number of attribute sources specified in  <B>pfMorphAttr</B>.  If
       <I>index</I>  is  &lt; 0, then <I>weights</I> is used for all attributes of
       <I>morph</I>. <B>pfGetMorphWeights</B> copies the weights of the <I>index</I>th
       attribute  of  <I>morph</I>  into  <I>weights</I>.  <I>weights</I> should be an
       array of at least <I>nsrcs</I> floats.

       A pfMorph node is evaluated, i.e., its  destination  array
       is  computed,  during the <B>APP</B> traversal which is triggered
       directly  by  the  application  through  <B>pfAppFrame</B>   (see
       <B>pfAppFrame</B>)  or  indirectly  by  <B>pfSync</B>.  Alternately, the
       pfMorph node may be explicitly evaluated  by  calling  the
       function  <B>pfEvaluateMorph</B>.  In all cases, destination ele-
       ments are computed as in the following pseudocode:

       zero destination array;

       for (s=0; s&lt;<I>nsrcs</I>; s++)
       {
           if (<I>ilist</I> == NULL || <I>ilist</I>[s] == NULL)
           {
            /* Source is non-indexed */
               for (i=0; i&lt;<I>nelts</I>; i++)
                   for (e=0; e&lt;<I>floatsPerElt</I>; e++)
                      dst[i][e] += <I>weights</I>[s] * <I>alist</I>[s][i][e];
           }
           else
           {
            /* Source is indexed */

               for (i=0; i&lt;nindex; i++)
                   for (e=0; e&lt;<I>floatsPerElt</I>; e++)
                      dst[<I>ilist</I>[s][i]][e] += <I>weights</I>[s] * <I>alist</I>[s][i][e];
           }
       }


       Note that the actual implementation is much more efficient
       than above, particularly for the special weights of 0 and
       1.

       Since pfMorph is a pfGroup, it is guaranteed to be evalu-
       ated before its children in the APP traversal. The pfMorph
       is only evaluated by the APP traversal when its weights
       change.

       <B>pfGetMorphNumAttrs</B> returns the number of <I>morph</I>'s
       attributes.

       <B>pfGetMorphSrc</B> returns the <I>src</I>th source parameters of the
       <I>index</I>th attribute of <I>morph</I>. The source attribute array and
       index array pointers are copied into <I>alist</I> and <I>ilist</I>
       respectively. The size of the <I>src</I>th index array is copied
       into <I>nlist</I> and the number of floats per element is
       returned by <B>pfGetMorphSrc</B>.

       <B>pfGetMorphNumSrcs</B> returns the number of sources of the
       <I>index</I>th attribute of <I>morph</I>.

       <B>pfGetMorphDst</B> returns the <I>index</I>th destination array of
       <I>morph</I>.  The destination array is either that provided ear-
       lier by <B>pfMorphAttr</B> or the pfCycleBuffer automatically
       created when <B>NULL</B> was passed as the <I>dst</I> argument to
       <B>pfMorphAttr</B>.



</PRE>
<H2>OBSOLETE</H2><PRE>
       <B>pfMorph</B> has been obsoleted by <B>pfEngine</B> and <B>pfFlux</B>.
       pfFluxes are multibuffered data objects for asyncrhonous
       evaluation, such as by pfEngines, that can be directly
       used as vertex attribute arrays, full pfGeoSets, matrices
       for <B>pfFSC</B> tranformation nodes, and other special asyn-
       chronous values for <B>pfLOD</B> and <B>pfSwitch</B>.  See these man
       pages for more information.




</PRE>
<H2>SEE ALSO</H2><PRE>
       pfAppFrame, pfCycleBuffer, pfGroup, pfDelete, pfEngine,
       pfFlux, pfLookupNode



                    pfMorph OBSOLETED by pfEngine and pfFlux(3pf)
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
